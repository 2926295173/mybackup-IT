> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7180600404236271671)

1. 前言
-----

本文为源码定制学习的 root 指纹抹除篇，通过本文的学习，读者可以掌握 Android 指纹的基本定制能力和 root 定制能力，本文参考了看雪大佬[应用 root 检测通杀篇](https://link.juejin.cn?target=https%3A%2F%2Fbbs.pediy.com%2Fthread-273485.htm "https://bbs.pediy.com/thread-273485.htm")，为实验记录笔记。有问题，可以一一指出：

本文第二节主要讲述基本原理

本文第三节主要讲述实验

本文第四节主要为总结

2. 基础知识
-------

### 2.1 指纹解析

需要对 Android 指纹进行修改，最重要是明白`build.prop`的参数含义，这里截取网上文章中的一部分，方便大家理解：

```
# begin build properties （开始设置系统性能）
# autogenerated （通过设置形成系统信息）
ro.=GRI40 (版本ID)
ro.build.=GRJ22 （版本号）
ro.build.version.incremental=eng.buildbot.20110619.060228 （版本增量）
ro.build.version.sdk=10 （sdk版本）
ro.build.version.codename=REL （版本代号）
ro.build.version.release=2.3.4 （Android 2.3.4系统）
ro.build.date=Sun Jun 19 06:02:58 UTC 2011 （制作者及制作时间）
ro.build.date.utc=0
ro.build.type=user (编译模式,如user,userdebug,eng,test模式)
ro.build.user=buildbot (编译账户)
ro.build.host=bb1 (编译主机系统)
ro.build.tags=test-keys (编译标签)
ro.product.model=HTC Wildfire （HTC内部手机代号）
ro.product.brand=htc_wwe （手机品牌）
ro.product.name=htc_buzz （手机正式名称）
ro.product.device=buzz （采用的设备）
ro.product.board=buzz （采用的处理器）
ro.product.cpu.abi=armeabi-v6j （cpu的版本）
ro.product.cpu.abi2=armeabi （cpu的品牌）
ro.product.manufacturer=HTC （手机制造商）
ro.product.locale.language=zh （手机默认语言）
ro.product.locale.region=CN （地区语言）
ro.wifi.channels= （WIFI连接的渠道）
ro.board.platform=msm7k （主板平台）
# ro.build.product is obsolete; use ro.product.device （旧代码ro.build.product，使用代码ro.product.device）
ro.build.product=buzz （建立产品）
# Do not try to parse ro.build.description or .fingerprint （不要试图修改description和fingerprint）
ro.build.description=passion-user 2.3.3 GRI40 102588 release-keys （用户的KEY）
ro.build.fingerprint=google/passion/passion:2.3.3/GRI40/102588:user/release-keys （系统指纹）
# end build properties （性能代码完毕）
#
# system.prop for buzz （系统技术支持由BUZZ提供）
#
# Density in DPI of the LCD of this board. This is used to scale the UI （高密度的液晶的DPI板。这是用来大规模UI的）
# appropriately. If this property is not defined, the default value is 160 dpi. （appropriately.如果这个属性没有定义,缺省值是160 dpi的分辨率）
ro.sf.lcd_density=240 （显示屏分辨率，数值越大分辨率越底，240就是800*480的）
# View configuration for QVGA. （屏幕的设置）
view.fading_edge_length=8
view.touch_slop=15 （触摸屏灵敏度，数值越大越灵敏）
view.minimum_fling_velocity=25 （滑动速度）
view.scroll_friction=0.008 （滑动误差）
# RIL specific configuration. （特定设置）
rild.libpath=/system/lib/libhtc_
ro.ril.ecc.HTC-WWE=999
ro.ril.ecc.HTC-ELL=92,93,94
ro.ril.enable.a52.HTC-ITA=1
ro.ril.enable.a53.HTC-ITA=1
ro.ril.enable.a52=0
ro.ril.enable.a53=1
ro.ril.vmail.23415=1571,BT
ro.ril.hsdpa.category=8 （hsdpa全称High Speed Downlink Packet Access中文意思：高速下行分组接入,设置的数越大传输越快）
ro.ril.htcmaskw1.bitmask=429496
ro.ril.htcmaskw1=14449
ro.ril.def.agps.mode=2 （打开AGPS服务支持，可改为ro.ril.def.agps.mode=0 改后能省电但GPS定位速度会变慢）
ro.ril.gprsclass=12 （GPRS设置）
# For HSDPA low throughput （HSDPA低输量）
ro.ril.disable.power.collapse=1 （关闭电源）
# Modify MMS APN retry timer from 5s to 2s. （修改短信的APN设置5秒为2秒）
ro.gsm.2nd_data_retry_config=max_retries=3, 2000, 2000, 2000
# Time between scans in seconds. Keep it high to minimize battery drain.（扫描在几秒之内，可降低用电量）
# This only affects the case in which there are remembered access points, （这个修改仅能影响此文件）
# but none are in range.（但是没有一项是在范围内的）
wifi.interface=eth0 （WIFI界面）
wifi.supplicant_scan_interval=45 （WIFI扫描间隔时间，这里设置是45秒。把这个时间设置长点能省电）
# Mobile data interfaces （移动数据的接口）
mobiledata.interfaces=rmnet0,rmnet1,rmnet2
# Allow or deny tethering. （允许和拒绝绑定）
ro.tether.denied=false
# Default network type. （默认的网络类型）
# 0 => WCDMA Preferred. （0=WCDMA优先）
ro.telephony.default_network=0
# Enable Google-specific location features, （谷歌特定地点的设置）
# like NetworkLocationProvider and LocationCollector.（如网络服务器提供商和服务器位置）
ro.c o m.google.locationfeatures=1
# The OpenGL ES API level that is natively supported by this device. （开放式绘图介面）
# This is a 16.16 fixed point number. （界面有16个点，16个不动点数量）
ro.opengles.version=65536 （开放式绘图介面参数）
# Disable fs check on boot by default. （开机时默认禁用FS检查）
sys.checkfs.fat=false
# Performance settings. （性能设置）
dalvik.vm.execution-mode=int:jit
dalvik.vm.heapsize=24m （虚拟内存大小，可设置为16m或24m或32m或48m）
persist.sys.use_dithering=1
persist.sys.purgeable_assets=1
# Increase SKIA decode memory capability for progressive jpg file.
ro.media.dec.jpeg.memcap=20000000
#
# ADDITIONAL_BUILD_PROPERTIES （其他性能设置）
no_require_sim=true （手机卡保护设置）
ro.rommanager.developerid=cyanogenmodnightly （固件管理器开发者是CM大神）
ro.url.legal=http://www./intl/%s/mobile/android/basic/phone-legal.html
ro.url.legal.android_privacy=http://www]/intl/%s/mobile/android/basic/privacy.html
ro. com.google.clientidbase=android-google （谷歌客户身份）
ro. com.android.wifi-watchlist=GoogleGuest （WIFI用户名单）
ro.setupwizard.enterprise_mode=1 （默认情景模式）
ro. com.android.dateformat=MM-dd-yyyy （默认时间格式，改为yyyy-MM-dd，显示效果就是XXXX年XX月XX日）
ro. com.android.dataroaming=false （漫游设置）
ro.config.ringtone=Playa.ogg （默认铃声设置，文件在/system/media/audio/ringtones 把喜欢的铃声放这里，比如123. MP3放入ringtones文件夹中，这里代码改为ro.config.ringtone=123. mp3）
ro.config.notification_sound=regulus.ogg （默认提示音，文件在/system/media/audio/notifications 修改方法同上）
ro.config.alarm_alert=Alarm_Beep_03.ogg （默认闹铃，文件在/system/media/audio/alarms 修改方法同上）
ro.modversion=CyanogenMod-7-06192011-NIGHTLY-buzz （版本信息，改这个能让你大名出现系统关于中，改为ro.modversion=xxxxx）
ro.setupwizard.mode=OPTIONAL （安装向导模式）
net. bt. name=Android （系统名称）
dalvik.vm.stack-trace-file=/data/anr/traces.txt
```

参考文章：[Android 系统 build.prop 文件生成过程](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fdd6cca4ec27d "https://www.jianshu.com/p/dd6cca4ec27d")

后面我们要修改设备的指纹，主要关注两个文件：`buildinfo.sh`和`Makefile`

### 2.2 root 检测方式

一般 Android 上 root 检测的基本方式包含：

```
（1）检查su命令是否存在
（2）检查常用目录是否存在su（或检测是否存在s权限的文件）
（3）使用which命令查看是否存在su
（4）主动申请root权限
（5）执行busybox
（6）检查Android属性（读取build.prop中关键属性，如ro.build.tags和ro.build.type）
（7）检查特定路径是否有写权限（在Android系统中，有些目录是普通用户不能访问的，例如/data、/system、/etc等）
（8）检查市面主流的模拟器
（9）检测frida、xposed等Hook框架的特征
```

具体可以分为：Android root 的系统指纹、root 的路径指纹、root 的执行操作、第三方工具等

参考文章：[修改 ROM 实现自定义 su 命令 - root 检测通杀](https://link.juejin.cn?target=http%3A%2F%2Flzonel.cn%2F3136.html "http://lzonel.cn/3136.html")，这里给出了一些基本的 root 检测指纹：

```
1.detectRootManagementApps—检测常见su包名,如{“com.noshufou.android.su”, “com.noshufou.android.su.elite”, “eu.chainfire.supersu”, “com.koushikdutta.superuser”, “com.thirdparty.superuser”, “com.yellowes.su”, “com.topjohnwu.magisk”, “com.kingroot.kinguser”, “com.kingo.root”, “com.smedialink.oneclickroot”, “com.zhiqupk.root.global”, “com.alephzain.framaroot”}

2.detectPotentiallyDangerousApps—{“com.koushikdutta.rommanager”, “com.koushikdutta.rommanager.license”, “com.dimonvideo.luckypatcher”, “com.chelpus.lackypatch”, “com.ramdroid.appquarantine”, “com.ramdroid.appquarantinepro”, “com.android.vending.billing.InAppBillingService.COIN”, “com.android.vending.billing.InAppBillingService.LUCK”, “com.chelpus.luckypatcher”, “com.blackmartalpha”, “org.blackmart.market”, “com.allinone.free”, “com.repodroid.app”, “org.creeplays.hack”, “com.baseappfull.fwd”, “com.zmapp”, “com.dv.marketmod.installer”, “org.mobilism.android”, “com.android.wp.net.log”, “com.android.camera.update”, “cc.madkite.freedom”, “com.solohsu.android.edxp.manager”, “org.meowcat.edxposed.manager”, “com.xmodgame”, “com.cih.game_cih”, “com.charles.lpoqasert”, “catch_.me_.if_.you_.can_”}

3.detectRootCloakingApps—{“com.devadvance.rootcloak”, “com.devadvance.rootcloakplus”, “de.robv.android.xposed.installer”, “com.saurik.substrate”, “com.zachspong.temprootremovejb”, “com.amphoras.hidemyroot”, “com.amphoras.hidemyrootadfree”, “com.formyhm.hiderootPremium”, “com.formyhm.hideroot”}

4.suPath—遍历执行可能存在的su文件夹,如{“/data/local/”, “/data/local/bin/”, “/data/local/xbin/”, “/sbin/”, “/su/bin/”, “/system/bin/”, “/system/bin/.ext/”, “/system/bin/failsafe/”, “/system/sd/xbin/”, “/system/usr/we-need-root/”, “/system/xbin/”, “/cache/”, “/data/”, “/dev/”}

5.checkForDangerousProps—检查一些属性的值.{ro.debuggable”, “1”},{“ro.secure”, “0”}

6.checkForRWPaths—先执行(需要root)mount如果返回true然后再查看是否有读写权限{“/system”, “/system/bin”, “/system/sbin”, “/system/xbin”, “/vendor/bin”, “/sbin”, “/etc”}

7.detectTestKeys—查看编译类型是否为 {“test-keys”}

8.checkBuildProp—检查Buildprop的值,{“ro.build.display.id”,”ro.build.version.incremental”,”ro.build.date”,”ro.build.date.utc”,”ro.build.type”,”ro.build.user”,”ro.build.flavor”,”ro.build.tags”,”ro.build.description”,”ro.build.fingerprint”,”ro.product.model”,”ro.product.brand”,”ro.product.name”}

9.checkSuExists—执行su,看看能否执行成功

10.checkForRootNative—Native层root检查

11.checkForMagiskBinary—检测是否存在Magisk-{“/data/local/”, “/data/local/bin/”, “/data/local/xbin/”, “/sbin/”, “/su/bin/”, “/system/bin/”, “/system/bin/.ext/”, “/system/bin/failsafe/”, “/system/sd/xbin/”, “/system/usr/we-need-root/”, “/system/xbin/”, “/cache/”, “/data/”, “/dev/”}
```

具体的大家可以参考原文

我在前面的文章：[Android 漏洞之战调试与反调试](https://link.juejin.cn?target=https%3A%2F%2Fbbs.pediy.com%2Fthread-272452.htm "https://bbs.pediy.com/thread-272452.htm")也用真实的代码进行了展演示，这里大家可以进行参考

3. 实验
-----

实验环境：

```
pixel Android8.0.1
Ubuntu 18
```

### 3.1 user 版本的编译

首先，我们编译 user 版本的镜像，里我需要编译的目标版本是`aosp_sailfish-user`，那么在编译的选项中是没有这一项的，根据`lunch`命令列出的文件，随意找一个文件进行修改，我们以`device/google/marlin/vendorsetup.sh`文件为例，进行修改

```
source build/envsetup.sh
```

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/1.png)

我们随便打开一个配置文件进行添加，例如这里我们打开配置文件`device/google/marlin/vendorsetup.sh`

```
vim device/google/marlin/vendorsetup.sh
```

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/2.png)

我们也可以发现之前的 userdebug 版本声明也在这里面

然后我们再次初始化并选择设备：

```
source build/envsetup.sh
lunch
```

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/4.png)

可以发现此时我们就多了 user 版本，然后我们选择该版本

编译：make -j4

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/5.png)

编译完成

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/6.png)

我们可以发现现在就是 user 的版本，也没有 root 权限，和我们平时使用的手机一样

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/8.png)

这里我们在网上找一个 root 检测工具，我们可以发现此时的手机是未经过 root 的

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/7.png)

尽管我们现在编译的是 user 版本，但是我们试验了一些测试的 APP，发现其中有一些 APP 还是检测系统含有 root，经过分析我们发现，无论是 user 编译还是 user-debug 编译，我们的系统签名都使用的是 test-key，而我们真正的手机一般是 release-key 签名后发布的，所以很多 APP 将这里作为检测点

这里有两种方案：

（1）编译 release-key 版本的系统

由于后面我们还要开展指纹抹除实验，所以这里给大家推荐一个文章，想要实现可以去试下：[Android——编译 release 版签名系统](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fu010142437%2Farticle%2Fdetails%2F78030485 "https://blog.csdn.net/u010142437/article/details/78030485")

（2）修改指纹

我们这里为了简单的实验，后面在实验中将这里的进行抹除

```
test-keys--->release-keys
```

然后为了开展后面的实现，我们尝试拿到 user 版本的指纹，由于此时无法 root，所以无法查看 `/system/build.prop`的信息，所以我们直接对设备进行 root

```
8.0刷入root步骤：
	（1）刷入twrp
	（2）使用twrp刷入Magisk
既可以获得root
```

针对 Android8.0 的设备获得 root，最方便的便是刷入 Magisk

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/9.png)

此时我们再次查看设备的指纹：

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/10.png)

可以发现此时我们可以找到指纹，这里我们保存该指纹信息

### 3.2 userdebug 版本编译

我们按上面的编译步骤选择 userdebug 版本

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/11.png)

我们可以发现 userdebug 的指纹明显不一样，此时我们再查看一下

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/12.png)

### 3.3 root 指纹抹除

前面我们分别对 user 版和 debug 版的系统进行了分析，相应不少朋友应对一些常见的 root 检测的应用进行处理，那能不能即获得 root 的操作，又拥有 user 一样的镜像呢，这里我们就需要对 root 进行定制和指纹抹除

首先我们用文件对比工具来进行比较：

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/13.png)

我们只需要将这些差异的地方一一进行修改即可

**（1）test-keys**

前面我们提到了这个问题，所以这里我们需要将其进行修改，这里直接将`test-keys`修改为`release-keys`

我们先查找一下位置：

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/14.png)

然后我们搜索`ro.build.tags`，可以在`buildinfo.sh`中找到

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/15.png)

然后我们继续定位后面的值，在`build/make/core/Makefile`中

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/16.png)

这里我们直接修改为`release-keys`

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/17.png)

**（2）ro.build.display.id**

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/18.png)

按照前面的思路进行定位：

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/19.png)

`build/make/core/Makefile`

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/20.png)

这里我们将其值修改为和 user 保持一致

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/21.png)

注意这里我们使用 release-key

**（3）ro.build.version.incremental**

这里我们可以将`buildinfo.sh`和`Makefile文件都修改`

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/22.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/23.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/24.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/25.png)

即我们修改`BF_BUILD_BUMBER`的值就可以了

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/26.png)

**（4）ro.build.date 和 ro.build.date.utc**

这两个是编译是时间，为了与后面保持一致，我们还是进行修改

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/49.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/48.png)

然后我们进行修改：

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/50.png)

**（5）ro.build.type**

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/27.png)

`buildinfo.sh`

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/28.png)

`Makefile`

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/29.png)

直接在此处修改即可

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/30.png)

**（6）ro.build.user 和 ro.build.host**

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/31.png)

`buildinfo.sh`

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/32.png)

这里我们直接修改为用户名和主机

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/33.png)

**（6）ro.build.flavor**

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/35.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/34.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/36.png)

然后我们直接进行修改

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/37.png)

**（7）ro.build.description**

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/40.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/38.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/39.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/41.png)

应修改为：

```
aosp_sailfish-user 8.1.0 OPM1.171019.011 eng.Windaa.20221109.050000 release-keys
```

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/42.png)![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/43.png)

**（8）ro.build.fingerprint**

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/44.png)

一样，我们进行定位

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/45.png)

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/53.png)

然后我们进行修改

```
Android/aosp_sailfish/sailfish:8.1.0/OPM1.171019.011/Windaa11090500:user/release-keys
```

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/47.png)

**（9）ro.product.model、ro.product.brand、ro.product.name**

一些朋友想要设备向 google 的原设备一样，可以修改手机的代号和产品名称，这里就不修改了，感兴趣朋友可以修改

### 3.4 root 定制

root 定制这里参考通用的方法：xu 为自定义的名称

```
AOSP/system/extras/su下修改Android.mk中su修改为xu
AOSP/system/core/libcutils/fs_config.cpp中/system/xbin/su修改为/system/xbin/xu
AOSP/system/sepolicy/private/file_contexts中/system/xbin/su修改为/system/xbin/xu
```

第一处

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/51.png)

第二处

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/58.png)

第三处

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/52.png)

### 3.5 编译

然后再次编译，选择 user-debug 版

```
lunch：24
make -j4
```

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/5.png)

### 3.6 效果演示

我们重新刷机，刷机完成后，就可以发现定制的镜像和原理看起来一致

定制后：

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/56.png)

定制前（user 版）：

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/8.png)

我们可以试下，看能不能正常 root

![](https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/57.png)

可以发现是没有问题的

4. 总结
-----

本文编译了 user 版和 user-debug 版，并通过指纹定制将 user-debug 魔改为 user 版，为后续试验提供了更多的方便，相关文件后续上传 github

5. 参考文献
-------

```
https://bbs.pediy.com/thread-273485.htm#msg_header_h2_0
http://lzonel.cn/3136.html
https://blog.csdn.net/u010142437/article/details/78030485
https://www.jianshu.com/p/dd6cca4ec27d
```

> 本文由安全后厨团队分享，转载请注明来源，违者必究！