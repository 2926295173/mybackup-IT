> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7030383914526965790)

第 6 章 静态分析
==========

```
静态分析是在程序尚未运行的状态下进行的逆向分析。

静态分析在逆向工程中使用频率非常高，需要分析人员具备较强的代码理解能力，这些都需要在平时的正向开发过程中不断积累经验。

本章将从常用的静态分析工具入手，先介绍主流的Hopper及IDA的基本用法，最后采用一个实例分别演示Hopper和IDA的分析过程。
通过对本章的学习，读者能够掌握iOS应用静态分析所需要的基本知识。
```

6.1 Hopper
----------

```
Hopper Disassembler（以下简称“Hopper”）是macOS平台下的一款逆向工具，主要用作静态分析。
它支持多种文件格式，拥有反汇编、伪代码、流程图、代码修改等功能，除此之外，还内置了Python解析器，可以根据需要编写特定的脚本来增强功能。
最新的v4版本已经完美支持ARM64指令集并针对Objective-C和Swift做了优化。
Hopper基于图形化操作，降低了学习使用的门槛，是逆向工程师的必备工具之一。
```

### 6.1.1 安装 Hopper

```
从官方网站https://www.hopperapp.com/下载Hopper最新版本（目前是v4版本）的dmg文件，打开后按照箭头所指，直接拖动到Applications文件夹即可。如图6-1所示。

需要说明的是，Hopper是收费软件，官方提供的版本是Demo版，主要有以下限制。
● 不能保存*.hop工程文件。
● 不能导出修改后的二进制文件。
● 使用时限为30分钟。

用于学习的话，这些限制并没有什么影响，如果需要解除这些限制，请选择购买正版，价格相对于下一节要讲解的IDA来说，已经非常划算了。
```

### 6.1.2 认识 Hopper

```
本节通过载入一个目标文件来认识Hopper及其常用功能的用法。
```

```
1.载入文件
单击“File”菜单下的“Read Executable to Disassemble…”选择目标文件之后，会打开选择架构的界面，如图6-2所示。

Hopper已经自动识别出当前文件为FAT的Mach-O文件，其中包含了ARMv7和AArch64（ARM64）两个架构的代码。
根据需要选择合适的架构进行分析，本例选择AArch64，单击“Next”按钮之后就是漫长的等待，直到分析完成，如图6-3所示。
```

```
2.区域划分图6-3所示的界面中，自上而下分别是工具栏和进度条，接着可以分为三个区域。
● 左边区域：包括目标文件中的所有符号、函数、字符串、标签列表，可以使用关键字进行过滤。
● 中间区域：反汇编窗口，用来展示汇编代码以及函数信息，分析人员可以阅读和修改反汇编代码。
  此区域下方用于展示当前的分析进度。
  此外，还可以通过Python脚本来调用Hopper的一些其他功能，使用更加灵活。
● 右边区域：检查面板，包含当前选择区域的上下文信息。
  当光标位于函数体的指令时，还会实时显示该指令的十六进制编码、所在行的注释、交叉引用等信息。
```

```
3.数据类型栏
很多工具在反汇编时可能无法正确区分数据和代码，Hopper也不例外，有些应用就是利用这点来对抗静态反汇编的。

Hopper提供了数据类型转换功能，可以手动把某段十六进制内容指定为代码或数据，
快捷工具栏从左至右依次为D（Data）、A（ASCII）、C（Code）、P（Procedure）和U（Undefined），如图6-4所示。
工具栏上的字母也是对应功能的快捷键，在光标所在位置按〈D〉键，数据类型会在db、dw、dd与dq间转换；

如果确定某段十六进制内容是以“\0”结尾的C字符串，只要把光标移到其第一个字符的偏移位置，按〈A〉键即可把它转换成ASCII码；

如果确定某段十六进制数据是一段指令，只要把光标移到其第一个字节的偏移位置，
按〈C〉键即可把它转换成代码；
按〈P〉键可以把某段代码定义为子程序，并且会自动推导出函数参数；
若要取消定义，则按〈U〉键重新以十六进制数据显示。
```

```
4.显示模式栏
为了便于分析，Hopper提供了一组显示模式栏来切换代码区的视图，如图6-5所示。
下面从左到右进行介绍。

● 汇编模式：这是大多数反汇编工具所提供的展现方式，默认用此方式，如图6-6所示。
第一列数字表示指令地址，紧随其后的是指令编码，可以在首选项中开启，
然后就是最重要的汇编代码，
最后一栏分号后面的是自动添加的一些注释。
最前面空白处的箭头代表跳转流程线。
例如在“0x0000000102619b44”处如果条件满足，就会向下跳转到“0x0000000102619b5c”处。

● 流程图模式：以更加结构化的方式展示代码流程，能够更加清楚地说明程序的走向，如图6-7所示。

● 伪代码模式：在此模式中，Hopper将会尽最大可能生成一些功能上与原始CPU指令等效的伪代码，如图6-8所示。

伪代码虽然是最简单的分析文件的方式，但也不是万能的。
由于某些应用采用了反静态分析手段，Hopper不可能得到一个完美的伪代码表示，甚至会丢失一些代码。
所以笔者建议，不要一味地相信伪代码，而是尽量以汇编代码和伪代码相结合的方式来分析程序。

● 十六进制模式：在此模式中，允许直接查看文件的字节，如图6-9所示。
图6-9中，第一列表示文件中的偏移量，
       后面是所有字节，如果此时双击某个字节，就能实时修改它。
这个模式一般用得不多，术业有专攻，编辑文件时通常采用功能更加强大的010 Editor。
```

```
5.右键功能
Hopper提供了丰富的右键菜单功能，随着所选内容的不同，弹出的右键菜单功能也有所不同。
比如在函数名上单击右键，可以重命名、查看引用，如图6-10所示。

在某个数值上面单击右键，将弹出各种进制转换、结构体转换、枚举类型转换等功能，如图6-11所示。
```

```
6.地址跳转
地址跳转也是个常用的功能，比如现在想定位到0x0000000100004934这个地址，可能要用鼠标一页页翻下去，直到找到这个地方为止。而用地址跳转就能一步到位。

Hopper支持以直接地址（包括符号名）和文件偏移的方式进行跳转，按〈G〉键即可打开跳转对话框，
如果选择文件偏移则输入“0x4934”，如图6-12所示。
```

```
7.交叉引用
交叉引用（XREF）是个非常重要的功能，在静态分析中使用非常频繁，它是指某个地址的数据或代码引用了哪些地址，以及被哪些地址的代码所引用。
比如现在想知道sub_100004934函数在哪里被用到，只需单击sub_100004934函数，按〈X〉键，就能看到所有引用它的地方，如图6-13所示。
```

```
8.修改代码
Hopper无须借助插件就能直接修改汇编代码，这是其他工具不具备的，在破解软件的时候非常有用。
单击需要修改的代码，单击“Modify”菜单下的“AssembleInstruction”，在弹出的对话框中输入对应的汇编语句，然后根据CPU模式选择ARM或Thumb，如图6-14所示。

修改完成后，单击“File”菜单下的“Produce New Executable”命令保存新的文件即可。
```

### 6.1.3 编写 Hopper 脚本实战

```
前面介绍时说过，Hopper支持Python脚本，这么有魅力的高级特性，怎能轻易放过？
本小节用一个实例来探讨脚本编写的一些思路。
```

```
1.需求分析
笔者准备了一个样本，因为本节重点不是讲分析，所以先大致交代一下算法。
sub_101b47cc8是一个简单的异或解密函数，根据传入的地址、密钥以及最大长度来进行解密，
如果某个字节和密钥异或的结果等于0或者循环次数超过最大长度则结束。
0x1028cf000是被加密字符串表的起始地址，
0xe82是待解密的字符串距离0x1028cf000的偏移值（实际地址就是0x1028cf000+0xe82），
0xbf是密钥，
0x31代表最大长度，
如图6-15所示。

这样的解密点有很多处，且每处调用时的密钥都不同，
由于是静态分析，所以不可能去Hook函数来打印解密后的字符串，
所以就需要借助Hopper的脚本功能，
根据当前光标所处的偏移地址及密钥信息来自动解密，并以注释的形式添加到Hopper里面。
```

```
2.梳理思路
由需求分析可知，要解密指定位置的字符串，需要先拿到偏移和密钥，所以脚本第一步就是要做这项工作。
通过观察几组解密特征码，发现这样一些特征：
● 带有偏移地址信息的指令总是“add x0, x0, offset”。
● 带有密钥信息的指令总是“movz w1, key”。
这给了大家一个很好的提示：只要得到这两句指令，就能根据特征码拿到offset（偏移）和key（密钥）。

由于Hopper官方没有提供脚本开发文档，所以只能从自带的例子和API源代码来着手。
在Hopper Disassembler v4.app/Contents/Resources/目录下有一个hopper_api.py文件，这就是Hopper脚本的API。

大致观察一下，会发现API分为
Tag、Procedure、BasicBlock、Instruction、Section、Segment、Document、GlobalInformation几大操作类。

由于要操作的是汇编指令，按照“指令”的字面意思来看应该归属于Instruction类，
搜索关键字发现仅有getInstructionAtAddress方法返回了Instruction对象，
而这个方法属于Segment类，代码如下：

通过名称和注释知道，
getInstructionAtAddress方法是根据传入的地址来得到汇编指令的。
到目前为止衍生出来两个问题：
一个是Segment对象从哪里来，
另外一个是传入的地址（当然是指光标所处位置）怎么获取。

通过对“Segment”关键字进行搜索，发现一个getCurrentSegment方法，它归属于Document类，顺藤摸瓜，
在Document类里面用“getCurrent”关键字查找到了getCurrentAddress方法，这正是用来获取当前地址的，
这样一来，上面提出的两个问题就解决了，代码如下：

到这里为止，光标所处位置的指令已经能获取了，把上面的过程进行整理后，伪代码如下：

现在只剩下指令判断和参数提取了，
庆幸的是Instruction类提供了getInstructionString方法，能得到指令的字符串形式，这样就可以用startswith来判断是否为“add”“movz”的指令了；
另外这个类还提供了getRawArgument方法，能从指令集里面提取参数，这意味着偏移地址可以用这个方法获取。

取完偏移值后，将当前地址加4即可取得下一条指令，从而拿到密钥，过程同上。以上整个过程可用图6-16所示的流程图表示。

解密完成后需要添加注释，使用Segment类提供的两个方法完成：
用getReferencesOf Address方法获取某个地址的所有引用，返回一个数组，之后对这个数组进行遍历；
调用setInlineCommentAtAddress方法给数组的每个元素添加注释。
```

```
3.新建脚本

单击“Scripts”菜单下的“Open Script Editor”，打开脚本编写对话框，
单击右下角的“+”按钮添加一个新的脚本文件，并重命名为“DecodeStr”，如图6-17所示。

脚本编写完成后，会在“Scripts”菜单下生成菜单项，如图6-18所示，记住这个快捷键以方便后续操作。

在需要解密的地方按快捷键执行脚本后，解密结果如图6-19所示。
```

6.2 IDA Pro
-----------

```
IDA Pro（Interactive Disassembler Professional，以下简称IDA）是由Hex-RaysSA公司开发的一款迄今为止最智能、功能最全面的交互式反汇编工具，可以在Windows、macOS、Linux操作系统上运行，在逆向工程领域几乎是无人不知，享有“屠龙刀”的称号。

IDA是一款商业软件，且价格不菲，每个授权一年大概需要几千美元的费用，在其官网https://www.hex-rays.com可以下载到Demo版本。
Demo版仅提供32位的PE、ELF、Mach-O格式的分析功能，且有30分钟的使用限制，如果需要完整版的功能，需要到官方购买，不过遗憾的是，由于某些原因IDA已经不再对个人用户开放购买权限，需要以企业的名义购买。

IDA支持数十种CPU指令集的反汇编，包括x86、x64、MIPS、PowerPC等。
从6.x版本开始已经支持ARM反汇编，最新的7.x版本除了优化Objective-C反汇编之外，还支持iOS的远程调试。
IDA目前支持主流平台的可执行文件反汇编，例如Windows平台的PE文件、Android平台的ELF文件、iOS平台的Mach-O文件等。
```

### 6.2.1 加载文件

```
IDA安装成功后会在桌面生成两个图标，其中，“IDA Pro（32-bit）”负责反汇编32位目标文件，“IDA Pro（64-bit）”负责反汇编64位目标文件。

一旦启动IDA，用户将会看到一个初始欢迎界面，上面显示许可证信息摘要。
初始界面消失后，IDA将显示另外一个对话框，为用户提供了三种加载文件的方式，如图6-20所示。

通过图6-20所示的三个选项进入的IDA主界面略有不同，下面进行简单说明。

● New（新建）：单击“New”按钮将启动一个标准的“File Open”对话框来选择将要分析的文件。根据选择的文件，IDA会显示另外一个或多个对话框，设置文件分析选项后再加载、分析该文件。

● Go（运行）：单击“Go”按钮后直接进入主界面，IDA将打开一个空白的工作区。这时，如果要打开一个文件，可以将该文件直接拖放到IDA的工作区，或者使用“File”菜单中的相关选项打开该文件。

● Previous（上一个）：单击“Previous”按钮可以打开“最近使用过的文件”列表中的某个已反汇编过的文件。

读者可以任意选择一个Mach-O文件，单击“Go”按钮进入主界面，使用“File”→“Open”菜单（或直接将目标文件拖入主界面所在的区域中）打开它，将看到图6-21所示的加载对话框。

此时IDA会自动识别打开的文件格式，大多数情况下保持默认选项即可。
单击“OK”按钮后会自动开始分析程序，分析过程依据目标程序的大小不同，耗时将从几分钟到数小时不等。
当IDA底部的“Output window”窗口输出“The initial autoanalysishas been finished.”日志时，说明分析完毕，如图6-22所示。

打开被分析的文件后会在原目录下生成4个文件，这是IDA创建的数据库文件，扩展名分别为.id0、.id1、.nam和.til，这些文件均为IDA专用，用户不要随意去修改它们。
```

### 6.2.2 功能划分

```
加载文件并分析完成之后，用户便可以根据需求进行逆向分析。
在进行逆向分析前有必要了解IDA界面的各种组件，IDA分析完成后的默认界面如图6-23所示。

下面按照编号逐一介绍。
1）工具栏（①）：包含与IDA的常用操作对应的工具。
  使用“View”→“Toolbars”菜单命令可以显示或隐藏工具栏，使用鼠标拖放工具栏可以重新调整它们的位置。
  默认的工具栏是基本模式的单排按钮，用户可以使用“View”→“Toolbars”→“Advanced mode”打开高级模式工具栏，显示全部工具按钮。

2）导航栏（②）：显示被加载文件地址空间的数据信息。
  默认情况下，它会呈现二进制文件的整个地址范围，右击导航栏内任何位置，并选择一个可用的缩放选项，可以放大或缩小显示的地址范围。
  单击导航栏任意位置，可以在反汇编窗口或十六进制窗口中跳转到选中的对应位置。
  不同的颜色代表不同类型的文件内容，导航栏下方列出了不同颜色所代表的含义，用户可以通过“Options”→“Colors”菜单命令打开颜色设置对话框，根据需要改变颜色，如图6-24所示。

3）反汇编窗口（③）：是逆向分析过程中使用频率最高的窗口，显示了被加载文件的反汇编代码。
  它有图形视图（默认）和文本视图两种形式，可以通过空格键在两种视图间进行切换。
  如果希望将文本视图作为默认视图，则必须通过“Options”→“General”菜单命令打开“IDA Options”对话框，选择“Graph”选项卡，取消勾选“Use graph view by default”复选框，如图6-25所示。

IDA的文本视图如图6-26所示，左边部分显示了区段名称+偏移，例如，选中行“__text:0000000100006B24”表示地址0000000100006B24处的代码处于.text段，
右边部分为反汇编代码或者数据内容。

IDA的图形视图能够清晰地显示一个函数的控制流程，通过〈Control〉键和鼠标滚轮可以缩放图形，如图6-27所示。

4）图形概况窗口（④）：在使用图形视图分析某个函数时，显示区域很少能一次将完整图形显示出来，这时，图形概况视图可提供缩小版的函数整体结构，其中的虚线矩形表示图形视图的当前显示位置。
  在图形概况窗口内单击，可重新定位其显示位置。

5）标签栏（⑤）：IDA将当前打开的每个子窗口以标签的方式显示，绝大多数分析工作都需要这些子窗口配合完成。
  IDA默认打开6个子窗口：
  IDA View-A（反汇编窗口）、
  Hex View-1（十六进制窗口）、
  Structures（结构体窗口）、
  Enums（枚举窗口）、
  Imports（导入函数窗口）、
  Exports（导出函数窗口）。
  通过“View”→“Open Subviews”菜单命令可以打开其他子窗口，如图6-28所示。

6）函数窗口（⑥）：
  用于列举IDA自动识别出的所有函数，双击选定的函数名，反汇编窗口会跳转到对应函数所在的起始地址，   单击右键弹出的快捷菜单可以编辑、删除某个函数。
  使用快捷键〈Control+F〉打开搜索文本框，输入关键字可以进行快速过滤，从而找到关键函数，如图6-29所示。
  
7）输出窗口（⑦）：用户可以找到与文件分析进度相关的状态信息，以及用户操作导致的错误信息等。
  IDA界面最下方的文本框用于执行脚本命令，同时支持Python和IDC脚本，单击“Python”按钮可以在两者间进行切换，
  如图6-30所示。对脚本感兴趣的读者可以学习IDA提供的语法文档。
```

### 6.2.3 保存 idb 文件

```
在准备关闭IDA或者打开另外的文件时，会弹出图6-31所示的对话框。

若使用默认选项“Pack database（Store）”，则会将之前提到的在分析过程中产生的4个数据库文件打包成一个idb（64位程序对应.i64）文件，并删除4个数据库文件。
若在原目录下已有该分析文件对应的idb文件，则会直接覆盖。
下次可以直接双击idb文件用IDA打开继续分析。

当用户不需要保存任何结果时，可以勾选“DON'T SAVE the database”复选框，此时仍然会删除4个数据库文件，但不会生成idb文件或者覆盖原有的idb文件。
```

### 6.2.4 常用功能及快捷键

```
在使用IDA进行静态分析时，熟悉一些常用的快捷键能提高分析效率。
IDA提供了丰富的快捷键功能，下面将介绍一些在静态分析过程中经常使用的快捷键。
● 空格键：在反汇编窗口中用于切换文本视图和图形视图。
●〈Esc〉键：退回到上一个操作地址。
●〈G〉键：地址跳转。在反汇编窗口或者十六进制窗口中按〈G〉键时，会弹出一个对话框，在文本框中输入地址或者符号，会跳转到指定地址，如图6-32所示。
●〈N〉键：对某地址进行重命名。符号表历来是逆向工程中的“必争之地”，防护方通常都会想尽办法把符号名抹去，因此，在分析没有符号的二进制文件过程中，对函数或者变量重命名就变得更加有意义。如图6-33所示，将0x100006B08地址的函数重命名为“_start”。
●〈X〉键：交叉引用一直是静态分析中一个极其重要的功能，它能更加直观地展示代码和数据之间的关系。IDA提供了大量显示和访问交叉引用数据的机制，如图6-34所示，查看NSLog()函数的交叉引用，可以看到在-[ViewControllerviewDidLoad]+48的地址调用了NSLog()函数。
●〈C/D/A/U/P〉键：代码数据切换。当IDA自动识别的内容无法满足需求时，用户可以自己控制IDA对文件内容的解析。
  快捷键〈C〉表示将光标所处地址的内容解析成代码，
  快捷键〈D〉表示解析成数据，
  快捷键〈A〉表示解析成ASCII码字符串，
  快捷键〈U〉表示解析成未定义的内容，
  快捷键〈P〉则表示解析成函数形式。
〈Alt+M〉组合键：在当前光标所在位置添加书签，如图6-35所示。
●〈Control+M〉组合键：显示所有书签，双击某个条目可以快速跳转到书签所指的地址处，如图6-36所示。笔者通常在重要的位置添加书签，方便管理。
〈Control+S〉组合键：显示所有段信息，包括区段名、起始地址、结束地址。双击某个条目可以跳转到对应区段的起始地址，如图6-37所示。
〈F5〉键：将汇编代码还原成伪代码，这是个重要功能，由IDA的插件提供（因为快捷键是〈F5〉，所以业界都称它为“F5插件”）。这个插件需要单独购买且价格不菲。
例如，对“-[ViewController viewDidLoad]”方法使用〈F5〉快捷键生成伪代码，如图6-38所示。
可以看到该插件对Objective-C的支持非常友好，逻辑清楚，几乎等同于源代码了。
这里再提醒一句，虽然〈F5〉很好用，但不要完全依赖它，在分析一些复杂函数时，生成的伪代码可能会存在一些问题，建议结合ARM汇编代码进行阅读和分析。
```

### 6.2.5 编写 IDA 脚本实战

```
6.1.3节编写的Hopper脚本中是在需要解密的地方执行脚本，此时有多处调用解密函数的话，就得操作多次，显得不太优雅。
本节采用IDA编写脚本，将思路变换一下：从解密函数着手，将调用它的地方一次性解密出来。
这样改良后的脚本，更加易于使用。
```

```
1.IDAPython介绍
  IDAPython是IDA集成的一个功能强大的脚本支持插件，对外提供了大量的IDA接口函数调用，逆向分析人员仅需具备简单的Python知识即可编写出实用的脚本，可以完全替代古老的IDC脚本。
  
  IDA官方提供了IDAPython的详细文档，可以在https://www.hex-rays.com/products/ida/support/idapython_docs/查阅，但是关于脚本开发的资料却是少之又少，所以只能从官方例子和API源代码中着手了研究了。
  
  在GitHub上可以找到官方的例子源代码（网址为https://github.com/idapython/src/tree/master/examples）。
  
  在/Applications/IDA Pro 7.0/ida.app/Contents/MacOS/python目录下有很多.py文件，这就是IDA脚本的API，如图6-39所示。
  
  大致观察一下，会发现API模块分为数据库、段、函数、指令、交叉引用、搜索、注释、符号、用户交互、数据代码识别、结构体、枚举、调试器、加载器及处理器等。
  
  IDA的API中同一个操作可以有多种实现方式。
  ● 使用idc.py中的idc函数，这些函数大多基于地址来获取和写入各种信息。
  ● 使用ida_xxx.py中封装好的抽象类。
```

```
2.梳理思路
使用IDA查看目标反汇编代码，发现它优化了代码的显示，但是实际含义跟Hopper是一致的，如图6-40所示。
（1）查找交叉引用
 首先需要获取所有调用sub_101B47CC8（后面直接称为“解密函数”）的位置。
 idautils.py是idc函数的高级封装集合，它提供了一个“def XrefsTo(ea, fags=0)”方法，可以找到函数的交叉引用（相当于按〈X〉快捷键的效果）。
 通过下面这个代码，将简单地把引用了解密函数的地址以十六进制的格式打印出来：
 for addr in XrefsTo(Ox101B47CCB,flags=0):
    print hex(addr.frm)

那么怎样运行这段脚本代码呢？
依次选择“File”→“Script command”菜单项，在弹出的“Execute script”对话框中选择脚本语言为“Python”，在右边编写脚本代码后单击“Run”按钮执行，结果会在底部的日志窗口显示出来，如图6-41所示。

（2）获取目标串的偏移及解密密钥现在需要从解密函数调用处提取目标串的偏移和密钥。

   为了达到这个目的，需要使用idc.prev_head(ea)方法，
   对解密函数的调用点进行逐条指令回溯来查找
   “add x0,x0, offset”和“movz w1, key”指令，
   然后使用idc.get_operand_value(ea,n)方法来获取真正的偏移地址。
   以下是代码实现：
   执行效果如图6-42所示。
```

```
3.解密算法实现
在字符串解密算法中需要将偏移地址处的字节逐个提取出来进行异或操作，可以使用idc.get_wide_byte(ea)方法来循环进行。代码如下：

执行结果如图6-43所示。
```

```
4.添加注释解密完成后需要添加注释。可以使用idc.set_cmt(ea, cmt, 0)方法将解密后的字符串分别添加到解密函数调用处及原始字符串的位置。
```

```
5.测试脚本将上面零散的测试代码进行整理，最终可以得到一个完整的脚本（具体见随书文件）。
最终测试效果如图6-44所示，所有调用的地方都被正确解密，而且在两处不同的地方添加了注释。
```

6.3 如何定位切入点
-----------

```
分析某个感兴趣的功能时，定位切入点很重要，否则会完全摸不着头脑。
在逆向工程领域，并没有固定的方法来做这件事，本节介绍的内容，仅是笔者在实际工作过程中使用的方法，希望读者在掌握它们的基础上，寻找更加优雅的方法，并将新的技巧分享到论坛中。
```

### 6.3.1 通过 Runtime 定位

```
Objective-C的运行时（Runtime）特性不但给开发人员带来了方便，也给逆向工程带来了极大的方便，在逆向初期，可以优先采用本方法定位关键点。

前面介绍过class-dump，它无需任何逆向工程知识，只需要通过关键字检索即可找到可疑函数，接着通过Hopper或者IDA进行静态分析。

对于小程序而言，用class-dump一般能轻松定位关键点。

反之，如果被逆向的目标程序比较复杂，在class-dump中不能轻易搜到关键字，则可以考虑使用Cycript等工具先分析UI，然后得到按钮事件，
接着通过Hopper或者IDA进行静态分析。
```

### 6.3.2 通过导入函数定位

```
Hopper或者IDA都有导入表窗口，列出了目标文件的所有导入函数，
在逆向分析中可以通过某个导入函数来定位关键点，
例如，如果某个功能里面存在输出日志的行为，那么就可以尝试搜索NSLog()函数来定位，如图6-45所示。
```

### 6.3.3 通过导出函数定位

```
Hopper或者IDA的导出函数窗口列出了目标文件的所有导出函数，
若目标文件没有抹去符号，则可以轻易在导出函数中找到入口地址，从而快速定位目标函数。
如图6-46所示，可以在输出函数窗口中定位到main函数的地址为0000000100006B24。
```

### 6.3.4 通过字符串定位

```
字符串搜索在静态分析中使用非常频繁，也是一种最直接的定位方式。
根据界面或日志信息中提示的字符串，在IDA中打开字符串子窗口，然后进行关键字搜索，找到后双击某条目，就定位到相关代码了，如图6-47所示。
```

### 6.3.5 通过网络行为定位

```
通过抓包可以快速分析某个功能的网络行为。这部分内容将在第11章进行详细介绍。
```

6.4 实例分析
--------

```
本节使用一个名为“UnCrackable_Level1.ipa”的CrackMe（供大家破解的小程序常用称谓），先后用Hopper和IDA进行分析，是对本章知识的总结。
通过本节的学习，读者能掌握一些实际的静态分析技术，以及IDA的多种文件修改技巧。
```

### 6.4.1 使用 class-dump 定位按钮事件

```
通常在拿到目标程序前，先不要急着分析，而是大致了解一下它，多研究它的功能，看它存在什么限制、通过什么方式来注册等，以方便后续寻找切入点。
先将UnCrackable_Level1安装到iOS设备并运行。
本例非常简单，只有一个文本框和一个按钮，并提示大家：有个标签被隐藏，上面存在需要的序列号。
现在任意输入一个伪序列号，单击“Verify”按钮进行试探，弹出错误提示，如图6-48所示。
按照6.3.1节介绍的运行时分析方法来定位按钮事件，用class-dump导出头文件后，发现仅有6个文件：

熟悉正向开发的话，一眼就能看出ViewController.h就是关键文件（即使不熟悉正向开发，此例中将文件逐个打开查看也很快）。
打开该文件，锁定了“-(void)buttonClick:(id)arg1;”方法，从命名不难看出这就是按钮单击事件：

下一步使用Hopper进行反汇编来分析该方法。
```

### 6.4.2 使用 Hopper 分析验证流程

```
用Hopper打开目标文件，待加载完成后，转到buttonClick:方法，如图6-49所示。
流程非常清晰，在“cbz w24, loc_100004594”代码处有一个明显的分支，出错就会提示“This is not the string you are looking for. Try again.”，
正确则提示“You found the secret!!”，

那么w24寄存器就是关键，只要w24满足条件就能注册成功。现在需要向上分析，看哪里控制了w24的值。
为了方便讲解，将视图切换回汇编模式，如图6-50所示。

单击“w24”，根据高亮的颜色向上找到了0x0000000100004538处，其汇编代码为“mov x24, x0”，也就是说x24寄存器的值受x0寄存器控制。

再向上看，会发现0x0000000100004534地址处调用了C函数objc_msgSend，在ARM64中，函数的返回值会通过x0返回，也就证明x24是某个函数的返回值。

大家知道，在Objective-C中，函数的调用最终都是通过objc_msgSend实现的，
且objc_msgSend的第一个参数（x0）是调用的类或对象，
第二个参数（x1）是真正调用的方法，
若被调用的方法携带参数，就会从x2寄存器开始进行传值。

现在从0x0000000100004534地址处调用的objc_msgSend函数开始向上逐个寻找参数，去除不必要的代码，整理得到x0的来源如下：
这样看就清晰了许多：x0=[[ViewController theTextField] text]。

熟悉正向开发的读者，一眼就能看出这是获取UITextField控件的文本框数据，而UI上面只有一个序列号文本框，所以x0必然就是输入的序列号了。

分析完x0，再看x1就会简单许多，只有0x0000000100004528地址处的一行代码：
根据Hopper的注释信息，可知x1实际指向isEqualToString:方法。
isEqualToString:方法归属于NSString类，用来比较两个字符串是否相等。
结合上面x0的数据，不难猜测此处是用输入的序列号和正确的序列号进行对比。

isEqualToString:方法接受一个参数，前面说过参数从x2寄存器开始传递，如果能找到x2的值就能拿到正确的序列号。向上分析代码，发现x2的流程和x0的流程相似，仅一处不同：

按照与前面同样的方法分析可知，这是对ViewController类的_theLabel属性进行操作，取其文本内容。

至此，buttonClick:的流程就分析完成了，总结一下就是将用户输入的序列号与_theLabel标签的正确序列号进行比较，如果相同就判断注册成功，伪代码描述如下：
那么问题来了，_theLabel标签在哪里呢？UI上面没有找到，但是提示说是隐藏掉了，所以需要想办法获取它的内容。
```

### 6.4.3 使用 IDA 分析序列号及修改代码

```
上一步利用class-dump定位函数，再用Hopper分析出了buttonClick:事件的验证流程，但在最后还是没拿到序列号，现在用IDA来解开这个谜。
将目标文件拖入IDA进行反汇编，找到buttonClick:方法，并在0x00000001000044F8地址后面的theLabel方法（即sel_theLabel方法，“sel_”是IDA自动添加的）按〈X〉键查看交叉引用，如图6-51所示。

这里看到theLabel在“-[ViewController viewDidLoad]+CC”处被引用，双击该条目加以跟踪，
如图6-52所示，发现ViewController调用了theLabel方法。

在0x0000000100004404地址处，通过objc_msgSend调用了theLabel方法，该方法返回了_theLabel（UILabel对象），

在0x0000000100004420处通过objc_msgSend调用了UILabel对象的setHidden:方法，参数为1（YES），使得_theLabel被隐藏起来。

继续往下看代码，发现在0x0000000100004480处，通过objc_msgSend调用了UILabel对象的setText:方法，该方法正是设置标签文本的，它的参数（X2寄存器）就是正确的序列号，

在0x000000010000447C处，X2由X21得到，而X21等于0x0000000100004454处的retainAutoreleasedReturnValue函数返回值X0，该函数由编译器自动加入，不用理会，
所以实际上X0的值是上面0x000000010000444C处调用objc_msgSend的结果，
而objc_msgSend调用的是stringWithCString:encoding:方法。将上述内容简化整理一下，得到如下关键代码：

stringWithCString:encoding:方法用来将一个C字符串转换成NSString对象，所以找到这个C字符串就意味着拿到序列号了。
然后继续往上找第一个参数（X2寄存器）的来源，在0x0000000100004438处看到X2等于X0，而X0是C函数sub_1000080D4的返回值，双击sub_1000080D4进去看一下，遗憾的是此函数代码已经做了加密处理，静态分析基本无法识别，所以留到动态分析章节再来追踪它，如图6-53所示.

序列号就要拿到了，却发现得不到明文——不要着急！条条大道通罗马，虽然看不到生成序列号的过程，但是在调用setText:方法时传入的却是解密后的字符串，
也就是说_theLabel标签上已经存在了完整的序列号字符串，现在只要想办法把_theLabel标签显示出来就行了。
前面调用setHidden:方法时，设置的参数是1（YES），那么把它改为0（NO）是不是就可以了呢？
该参数位于0x000000010000441C地址处，汇编代码为“MOV W2, #1”，可以使用Hopper直接修改其为“MOV W2, #0”。
此处是使用IDA分析，下面就讲解IDA修改字节的几种方式。
```

```
1.通过“Hex View”窗口进行修改
  在修改前，先通过http://armconverter.com/在线转换“MOV W2, 0”指令，得到的机器码为“02008052”。
  切换到Hex View窗口，按〈Control+G〉快捷键后输入“000000010000441C”，跳转到对应位置，然后单击右键，在弹出菜单中选择“Edit”命令，即可进行字节修改，如图6-54所示。
  修改完成后再次单击右键，选择“Apply changes”命令即可，如图6-55所示。
这时再看反汇编窗口，已经成功修改，如图6-56所示。
```

```
2.通过“Patch program”修改使用“Hex View”窗口修改字节比较烦琐，下面用一个简单点的方式修改。
  选中目标地址，依次选择“Edit”→“Patch program”→“Change byte”命令，按照需求修改后单击“OK”按钮即可，如图6-57所示。
```

```
3.通过插件修改
  上面两种方式都要预先转换机器码再直接修改，不是特别优雅。
  IDA没有提供Hopper那样直接修改汇编代码的功能，但是有个很强大的keypatch插件可以做到。
  keypatch是IDA插件设计大赛获奖作品，专为补丁而生，直接写汇编代码就能对程序进行修改，免去了转换机器码的烦琐过程，支持ARM、ARM64、PowerPC、x86、x64等CPU架构。
keypatch是开源的，代码托管在GitHub：https://github.com/keystone-engine/keypatch。

keypatch基于Python编写，无须编译就能使用，底层依赖keystone-engine，所以需要先安装它，具体如下：
sudo pip install keystone-engine

之后将从GitHub下载的keypatch.py文件放到IDA的插件目录（例如：/Applications/IDA 7.0/ida.app/Contents/MacOS/plugins）下，关闭IDA重新载入目标程序，在需要修改的代码行右击，
再依次选择“Keypatch”→“Patcher”命令，在弹出的对话框中可以直接修改汇编代码，如图6-58所示。

默认勾选的“Save original instructions in IDA comment”可以将原始指令以注释的方式添加到被修改的代码后面，方便补丁管理。
```

```
使用以上三种方法修改文件后，该如何保存呢？
依次单击“Edit”→“Patchprogram”→“Apply patches to input file”打开对话框，选项通常保持默认，笔者建议勾选“Create backup”复选框（表示在应用补丁前将目标文件先进行备份，方便以后还原），单击“OK”按钮，补丁就打好了，如图6-59所示。

将打好补丁的文件通过scp或者PP助手上传至设备，替换原来的文件。
此时运行可能会闪退，解决方法是重新添加执行权限，具体如下：

chmod +x /var/mobile/Containers/Bundle/Application/7396EAF7-39BF-43E0-8206-10202179D920\UnCrackable\Level\1.app\UnCrackable\Level\1

注意把“7396EAF7-39BF-43E0-8206-10202179D920”替换成自己设备上相应的路径。
再次运行，页面左上角已经多了一个UILable，其内容为“i am groot!”，将它输入后再次单击“Verify”按钮，提示成功，如图6-60所示。
```

6.5 本章小结
--------

```
本章通过实例介绍了Hopper及IDA反汇编工具及其用法，其中穿插了Hopper与IDA脚本的开发细节。

笔者将逆向工程中比较重要的“定位切入点”的方法也归纳到本章，最后通过一个完整实例收尾，对本章所学的知识进行了综合。

静态分析需要大量的知识积累，在学习完本章之后，相信读者深有体会，
只有多写代码才能区分哪些是控件方法、哪些是系统方法及哪些是自定义方法。
如果学习本章时感到吃力，请先补习一下基础知识，下一章将带领读者进入动态调试的世界
```

第 7 章 动态调试
==========

```
第7章 动态调试
动态分析属于逆向工程领域最重要的技能，需要配合相关的调试技术进行。
动态调试的最大魅力是灵活可变，对于某些不确定的元素，在静态分析中就必须联系上下文进行分析与猜测，而动态分析时只需要把相关寄存器或栈内容打印出来便一目了然，甚至可以直接修改返回值来验证结果的准确性。
静态分析与动态分析是相辅相成的，在完整的逆向工程中缺一不可。
本章除了重点讲解LLDB调试器的使用方法、脚本编写、实例分析之外，还将介绍IDA及Xcode的动态调试方法。
```

7.1 LLDB 动态调试
-------------

```
在Windows平台下有OllyDBG、WinDBG等众多优秀的调试器，

在macOS平台下，可选的只有LLDB（Low Level Debugger），
它具备本地调试macOS应用及远程调试iOS应用的能力，取代了曾经的GDB，成为Xcode中内置的调试工具。
它具有REPL（交互式解释器）特征，支持用C++或Python编写插件来增强功能。
LLDB基于控制台操作，没有像Windows平台下的OllyDBG一样的图形界面，因此初学者使用起来会相对吃力一些，希望读者能克服这些困难。

这是iOS逆向工程必经之路，一旦掌握其技巧，大家会发现调试的世界是如此美好！
本章将通过IDA静态分析与LLDB动态调试的结合，以实例来分析应用程序的某些功能，让大家领略到双剑合璧的魅力。
```

### 7.1.1 配置 debugserver

```
LLDB只能运行在macOS上，若要调试iOS应用，则需要先在设备上运行一个叫作debugserver的工具。
debugserver扮演着服务器的角色，把在macOS端执行的各种LLDB命令传递给设备端，并把设备端的结果反馈到macOS终端，这种调试方式通常称为远程调试（Remote Debugging）。
在进行远程调试前需要对debugserver进行一些配置，具体如下。

1.导出debugserver
  如果当前的iOS设备进行过真机调试，那么debugserver会被自动安装到Develpoer/usr/bin目录，使用scp或者PP助手将其导出到macOS上，如图7-1所示。
  
2.给debugserver添加权限
  由于debugserver缺少task_for_pid权限，所以只能调试自己的应用，若想要调试第三方应用，就需要对debugserver进行处理，
  另外，iOS 11运行还需要加上platform-application权限。
  
  在刚刚导出的debugserver同级目录下创建一个名为“ent.xml”的文件，并输入相应的内容：
    <?xml version="1.0" encoding="utf-8">
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/propertyLIST-1.0.dtd">
    <plist version="1.0">
     <dict>
      <key>com.apple.sprintboard.debugapplications</key>
      <true/>
      <key>run-unsigned-code</key>
      <true/>
      <key>task_for_pid-allow</key>
      <true/>
      <key>platform-application</key>
      <true/>
     </dict>
    </plist>
 
  使用codesign进行签名，特别注意-s参数后面的“-”不要漏掉：
  codesign -f -s - --entitlements ent.xml ./debugserver
  ./debugserver:replacing existing signature

3.复制签名后的debugserver到设备
  将处理后的debugserver放回iOS设备，并添加执行权限，命令如下。
  scp -P22222 ./debugserver root@localhost:/usr/bin/
  iPhone6-Debug:/ root# chmod +x /usr/bin/debugserver
  
把debugserver复制到“/usr/bin”目录的好处是，在任意目录下都可以直接运行debugserver，而无须输入形如“/path/to/debugserver”的全路径。

debugserver的配置已完成，下一节将讲解如何与LLDB建立连接。
```

### 7.1.2 与 LLDB 建立连接

```
1.开启debugserver
  与其他平台调试器一样，debugserver可以直接启动和附加进程，它们的命令都比较简单，下面分别进行介绍。
（1）启动进程命令格式为：
 debugserver -x backboard IP:PORT /path/to/executable
 debugserver会启动executable，并开启PORT端口，等待来自IP的LLDB连接，如果IP地址输入“*”号，表示接受任意IP的链接

例如，debugserver启动MobileNotes进程，并开启8888端口，等待来自192.68.1.123的LLDB连接，命令如下。
iPhone6-Debug:/ root# debugserver -x backboard 192.68.1.123:8888 /Applications/MobileNotes.app/MobileNotes

（2）附加进程
 命令格式为：
 debugserver IP:PORT -a ProcessName
 debugserver会附加ProcessName，并开启PORT端口，等待来自IP的LLDB连接
 
 例如，debugserver附加到iThunder进程，并开启8888端口，等待来自任意IP的LLDB连接，命令如下。
iPhone6-Debug:/ root# debugserver *:8888 -a iThunder

debugger还可以使用进程ID方式附加到目标，所以命令可以改为：
ps -ax ｜ grep iThunder
debugger *:8888 -a 841

启动或附加进程成功后，iOS设备就会等待macOS终端LLDB的接入，此时debugger的准备工作就完成了
debugserver *:8888 -a 841
```

```
2.LLDB连接debugserver
（1）端口转发
  LLDB连接debugserver可以使用Wi-Fi进行，但笔者不建议这样做（当然，如果使用Wi-Fi方式连接，端口转发步骤就不需要了，将第2步的IP改为设备的IP即可），因为Wi-Fi既不稳定，速度又特别慢。
  这里使用前面章节介绍的usbmuxd进行端口转发，再通过USB方式连接。具体如下。
  iproxy 8888 8888 你的设备UDID
  
（2）LLDB连接
  进行端口转发后，接下来就准备进入LLDB模式，然后连接debugserver了。
  首先在终端输入LLDB命令，然后输入IP进行连接。因为上一步已经进行了端口转发，所以可以使用localhost或者127.0.0.1来进行debugserver连接，命令如下。
  proxy connect connect://localhost:8888
  
 该命令执行完毕后，进程处于等待调试的状态
 lldb
 process connect connect://localhost:8888
```

```
（3）简化连接流程每次连接时都需要输入
  “process connect connect://localhost:8888”命令，时间长了，很容易忘记，这时可以利用LLDB的配置文件来简化这一过程。
  LLDB在启动时会读取～/.lldbinit文件（没有的话，新建一个），在这里可以设置很多有用的东西，比如设置别名、修改命令提示符等：
  # 利用别名简化链接
  command alias con pocess connect connect://localhost:8888
  # 个性化提示符
  settings set prompt "\[PiaoYunDbg]$"
  
  修改配置文件以后，在建立连接的时候只要输入“con”就可以了，提示符也变成了“[PiaoYunDbg]$”，如图7-4所示。
```

### 7.1.3 LLDB 命令详解

```
LLDB连接成功后，将会进入阻塞状态，等待用户输入调试命令，本节以iThunder的登录功能为例来讲解常用命令的使用方法。
  通过运行时工具分析iThunder的登录界面，可得到它的控制器为LoginViewController，
  再通过静态分析得知，在输入账号、密码后，单击“登录”按钮最终会调用“-[XLMember ManagerloginByUserName:password:verifyCode:verifyKey:finishBlock:]”方法。该方法对应的偏移地址为0x0000000100868B50，如图7-5所示。
先记住此地址，后面的调试工作均由此展开。
```

#### 1. 获取 ASLR 偏移值

```
1.获取ASLR偏移值
  在该地址添加断点之前，需要先找到主程序的ASLR（地址空间布局随机化）偏移值，这个值每次都不同，读者需要注意。使用如下命令获取。
  image list -f -o
  
  该命令打印出的信息有3列，第1列是被加载的模块序号，第2列是模块完整路径，第3列出现了两个值，括号外的“0x00000000000b0000”即要找的ASLR偏移值，而括号内的“0x0000000100048000”则是模块的实际内存加载地址。
  由于ASLR的存在，实际加载地址每次都会不同，这是iOS的一种保护机制。
  得到ASLR偏移值之后，函数的实际内存地址可以用下面的公式计算。
  函数实际内存地址=ASLR偏移量+IDA中显示的文件偏移
```

#### 2. 断点操作

```
2.断点操作
  断点是在动态调试过程中使用频率最高的操作，只有当断点触发时，才能执行后面的操作。
  LLDB中与断点有关的命令是breakpoint（可以简写为“br”）。
  使用set参数给某地址设置断点，具体格式如下。
    breakpoint set --address 断点地址
    # 或
    break set --address ASLR偏移量 + IDA中显示的文件偏移
    # 也可以简写为；
    br s -a ASLR偏移量+IDA中显示的文件偏移
    
  对目标地址设置断点后，输入"c",再按〈Enter〉键，让程序继续运行：
    breakpoint set --address 0x00000000000b0000+0x00000001
    c
  
  此处断点编号为1，list参数用来列出所有断点，
  disable/enable/delete参数分别表示禁止/启用/删除某个编号的断点：
   breakpoint list
   breakpoint disable1
   breskpoint enable1
   breskpont delete 1
  
  在运行过程中，可以随时按〈Control+C〉快捷键或使用如下命令使程序再次中断：
   process interrupt
   
  在登录界面输入用户名“piaoyun”，密码“123456789”，单击“登录”按钮，如图7-6所示。
  如果没问题，断点1应该被成功触发，程序被中断。此时就可以查看上下文信息，读取寄存器、内存数据、程序参数及调用栈等。
```

#### 3. 寄存器操作

```
3.寄存器操作
LLDB中操作寄存器的命令是register，下面讲解如何读取和修改寄存器。
（1）读取寄存器
使用read参数默认读取整个寄存器，也可以指定读取某个寄存器，具体如下。
  register read
  register read $x0
 
（2）修改寄存器使用write参数对某寄存器的值进行修改，此处对x4寄存器进行临时修改：
  register write $x4 1
  register read $x4 0
```

#### 4. 打印操作

```
4.打印操作
  被中断的是Objective-C函数，由objc_msgSend调用，因此
  x0寄存器保存了被调用的类，
  x1寄存器保存了实际调用的方法。
  若实际方法带有参数，则依次从x2～x7寄存器传递。
  本例有5个参数，所以打印了x2～x6的值：
  po $x0
  po [$x0 config] #打印XLMemberManager类的config属性
  
  x/s $x1
  
  po $x2
  po $x3
  po $x4
  po $x5
  po $x6
  
  p/x $x7
  p/d $x7
  p/t $x7
 
 po（print object）命令用于打印Objective-C对象，这里打印了XLMemberManager类的config属性，返回值是一个XLMemberConfigure对象。
 “x/s$x1”命令将x1寄存器的C字符串打印出来。
 
 P(print)命令输出原生类型（boolean、integer、foat等）的信息，可以指定其输出格式。
```

#### 5. 内存读写

```
5.内存读写
LLDB中操作内存的命令是memory，主要分为读取、保存与修改，下面分别进行讲解。

（1）读取内存
  使用read参数读取指定内存，支持寄存器地址和内存地址读取，-c参数指定要读取的字节，具体如下。
  memory read $x0
  memory read 0x00000014f6a9f30 -c 100
  memory read 0x00000014f6a9f30 0x000000014f6a9f40 #按区间读取
  如果被读取的数据超过1024字节，就会出现错误，加入--force参数即可解决：
  memory read 0x00000014f6a9f30 -c 1025
  
（2）保存文件
  读取的内存数据可以使用-outfile参数保存到文件：
  memory read 0x000000014f6a9f30 -c 1025 --force --outfile /tmp/1.txt
  如果是需要保存原始字节，加入--binary参数即可：
  memory read 0x000000014f6a9f30 -c 1025 --force --binary --outfile /tmp/1.txt
  
（3）修改内存
  使用write参数对内存数据进行修改，具体如下。
  memory write 0x000000014f6a9f30 0x24 #修改成0x24
  memory read  0x000000014f6a9f30
  memory write 0x000000014f6a9f30 0x25 #修改成0x25
```

#### 6. 内存监视

```
6.内存监视
watchpoint用来监视某个内存的变化，可以理解为内存断点。
比如在调试游戏数据时，想知道生命值什么时候被修改就可以使用它。
它包括访问（read）、写入（write）及读写（read_write）三种类型，分别如下。

（1）内存访问
watcpoint set espression -w read --0x000000014f6a9f30

（2）内存写入
watchpoint set expression -w wirte --0x000000014f6a9f30

（3）内存读写
watchpoint set expression -w read_write --0x000000014f6a9f30

除此之外，还能指定条件进行监视，如下所示。
watchpoint modify -c '*(char *)' 0x000000014f6a9f30 == 20'

与br断点功能一样，watchpoint同样具有disable/enable/delete参数：
watchpoint list
watchpoint disable 3
watchpoint enable 3
watchpoint delete #不带参数将删除全部监视
```

#### 7. 反汇编 disassemble

```
7.反汇编
disassemble（可以简写为“dis”）命令可以反汇编指定地址，支持寄存器所对应的地址或直接地址，具体如下。
disassemble -a 0x100918b50 
#或者
disassemble -a $pc iThunder '__lldb_unnamed_function52116$$iThunder:
```

#### 8. 调用栈

```
8.调用栈
调用栈描述的是函数之间的调用关系，在动态调试中非常有用。
使用bt命令可以打印出所有调用栈，后面加入编号可以指定打印几层，具体如下。
bc
bt 1
bt 2

这里看到frame #1对应的地址是 0x0000000100909f04，用此地址减去ASLR的偏移量即得到文件偏移地址：
p/x 0x0000000100909f04-0x000000000b0000
(long)$10=0x000000100859f04

转到IDA的0x0000000100859f04地址可以验证调用栈的正确性，如图7-7所示。
```

#### 9. 查找 C 函数

```
9.查找C函数
Image命令的参数众多，其中lookup参数不可小视，以下代码为利用lookup查找C函数地址。
image lookup -r -n ptrace
```

#### 10. 单步命令

```
10.单步命令
下面这4个单步命令在动态调试中使用频率极高。
（1）ni单步执行，遇到子函数不进入。
例如下面的代码，在0x100918b50地址处输入“ni”命令，会执行到下一行：
ni

（2）si单步执行，遇到子函数则进入。
 例如下面的代码，在0x100918c5c地址处输入“si”命令，会进入0x1015537d0地址处的objc_msgSend函数：
 si
 
 （3）finish完成功能并退出子函数。
 例如下面的代码，在objc_msgSend函数内任何地址输入“finish”命令，将在完成objc_msgSend原始调用后，返回到0x100918c60地址：
 finish

（4）return与finish命令不同的是，return会直接退出子函数，因此原始代码流程不会调用。
 该命令通常在反-反调试时用于跳过检测函数。
 
 LLDB命令实际上会做前缀匹配。如对于register命令，也可以使用reg或者regi，但不能使用re，因为LLDB不能消除和reload的歧义。
 其实很多命令都是简写或者别名。
 LLDB的命令行很多，本书不能完全列出，这时，帮助命令就派上用场了。
 直接在LLDB命令交互模式下输入“help”，会列出所有的命令及其简单描述，输入“help命令名”，可以查看该命令的详细用法。
 例如查看breakpoint命令的用法，如图7-8所示。
 help breakpoint
 
 有时，大家只需记住命令所包含的关键词，然后使用apropos来帮助搜索。
 apropos是不区分大小写的，并且将返回LLDB文档中匹配的任何结果。例如搜索任何与“breakpoint”有关的内容，如图7-9所示。
 apropos breakpoint
```

### 7.1.4 LLDB 手动脱壳

```
第4章介绍了如何使用Clutch、dumpdecrypted或bfinject对从App Store下载的应用进行自动脱壳，然而，这些工具可能在新的越狱系统上因为适配问题或某些应用针对它们进行了防护而脱壳失败，这时候就可以采用LLDB进行手动脱壳。
 LLDB手动脱壳的实现原理是从内存中dump出解密后的数据并修复Mach-O头部。本节以WhatsApp的主程序脱壳为例，讲解LLDB脱壳的方法。
```

#### 1. 收集信息

```
1.收集信息
  在脱壳之前，需要先把目标文件复制到macOS上，利用工具查看一些信息，为脱壳做准备。
  通常先在设备上运行目标应用，然后使用ps命令得到目标路径（由于目标文件路径太长，笔者通常将其复制到/tmp目录下），然后使用scp将WhatsApp放回本地，具体如下。
  #ios端操作
  ps -ax | grep WhatsApp
  cp /var/mobile/Containers/Bundle/Application/BA96A327-E246-43A6-9D68-148607CE9FE3/WhatApp.app/WhatsAPP /tmp
  #mac端操作
  cd ~/PYGiOSReBook/tmp/
  scp -P2222 root@localhost:/tmp/WhatsApp ./
  
  要在内存中解密二进制文件，就需要知道加密数据的偏移量及大小。
  使用otool工具查看该二进制文件的LC_ENCRYPTION_INFO信息：
  otool -arch arm64 -l ./WhatsApp | grep -A 4 LC_ENCRYPTION_INFO
  
  由于笔者使用的是ARM64架构的设备，因此指定“-arch arm64”，读者请根据实际情况修改。
  记住cryptoff和cryptsize的值，下一步需要使用。
```

#### 2. 开始脱壳

```
2.开始脱壳
  在设备启动debugserver后，使用LLDB附加进程，然后获取WhatsApp的内存加载地址：
  lldb
  con
  image list -f -o WhatsApp
  
  需要注意的是，这里不是获取ASLR偏移量，而是要获取内存加载地址（即0x00000001000bc000）。
  接着，利用memory命令从内存中dump出解密后的二进制数据，保存到文件。具体如下。
  memory read 0x00000001000bc000+16384 -c 15989664 --force --binary -outfile ./WhatsAppDecrypted
  
  16384是上一步通过otool获取的cryptoff值，
  0x00000001000bc000+16384是当前模块内存加载地址+加密数据的偏移地址（通俗地讲，就是把指针移动到被加密的数据块），
  15089664是cryptsize的值，也就是被加密数据块的大小。
  “--binary -outfile”使用二进制方式将数据写入decrypted.bin文件。
```

#### 3. 修复文件

```
3.修复文件因为dump出来的数据是没有Mach-O头部信息的，所以需要修复才能使用。
修复的方法也有很多种，这里采用最快捷的方法：将dump出来的数据重新写回脱壳前的文件，以替换加密的数据：
dd seek=16384 bs=1 conv=notrunc if=./decrypted.bin of=WhatsApp

seek值指明需要在WhatsApp的何处开始写入解密后的数据。
目标程序只有一个ARM64架构，因此架构偏移值是0，
16384是加密数据的偏移值cryptoff，两者相加就是seek值了。

如果目标程序有多个架构，就要先使用“otool -hf”查看待修复架构的offset字段，然后和cryptoff相加，即得到seek值。

最后一步就是修改加密标记：用MachOView打开修复后的文件，定位到“LC_ENCRYPTION_INFO_64”，修改cryptid的值为0，如图7-10所示。
```

### 7.1.5 LLDB 脚本编写

```
通过前面的调试，读者应该注意到，在LLDB添加断点之前都有一个查找ASLR的过程，操作极其不便。
其实，LLDB提供了强大的Python脚本扩展，利用它可以将这些流程简化，在官方网站http://lldb.llvm.org/python-reference.html中可以找到详细资料。
本节将编写两个实用的脚本命令，它们会自动处理ASLR，方便后续使用。
bp命令：根据传入的文件偏移即可添加断点。
foff命令：根据传入的内存地址计算文件偏移。
```

#### 1. 创建新的命令

```
1.创建新的命令
根据文档要求，创建一个新的LLDB命令函数时，需要定义4个参数，如果给该函数添加了注释，可以在LLDB交互界面中使用help命令查看帮助。定义如下。

def BP(debugger, command, exe_ctx, result, interal_dict):
  """
  BP断点-自动处理ASLR
  """
  #此处编写代码


从SVN修订版218834开始，对该命令函数进行了扩充，增加了一个exe_ctx参数，定义如下。

def BP(debugger, command, exe_ctx, result, interal_dict):
  """
  BP断点-自动处理ASLR
  """
  #此处编写代码

各参数的类型及含义见表7-1。
参数      类型             描述
debugger lldb.SBDebugger 当前调试器对象
command  Python字符串     命令参数字符串
exe_ctx  lldb.SBExecutionContext 执行上下文对象
result   lldb.SBCommandReturnObject 返回对象
internal_dict Python字典 当前脚本会话的字段对象，包含所有变量和函数
```

#### 2. 完成命令功能

```
2.完成命令功能
BP命令函数的功能是根据输入的文件偏移添加断点，
实现思路是用脚本先获取ASLR偏移值，然后加上输入的文件偏移参数，再使用breakpoint set--address命令添加断点即可。

LLDB脚本使用lldb.SBCommandInterpreter类的HandleCommand方法处理命令，若需要获取命令执行结果，则需要传入一个类型为lldb.SBCommandReturnObject的变量。

所以BP命令函数可以按照如下方法编写。
```

```
import lldb
 import re
 import os
 import shles
 
 #获取ASLR偏移地址
 def get_ASLR():
     #获取断点
     interpreter = lldb.dubugger.GetCommandInterpreter()
     #保存结果
     result_obj = lldb.SBCommandReturnObject()
     #处理'image list -o '命令',并返回结果到return_obj
     interpreter.HandleCommand('image list -o',return_obj)
     #获取所有返回值
     output=return_obj.GetOutpput();
     #正则匹配出第一个以"0x"开头的十六进制地址
     match = re.match(r'.+(0x[0-9a-fA-F]+)',output)
     if match:
       return match.group(1)
     else:
       return None
       
def BP(debugger,command,rsult,internal_dict):
     """
     BP断点-自动处理ASLR
     """
     fileoff = shlex.split(command)[0]
     if not fileoff:
       print>>result,'Please input the address!'
       return
       
     aslr = get_ASLR()
     if aslr:
       #如果找到了ASLR偏移，就设置断点
       debugger.HandleCommand('breakpoint set --address "%s+%s"' %(aslr,fileoff)
     else:
       print>>result,'ASLR not found!'
```

```
以上代码先从command参数里面取得文件偏移值，
接着调用get_ASLR()获取ASLR偏移值，
最后调用debugger.HandleCommand()对两者相加的地址添加断点。
 
另一个函数FileOffset的逻辑则恰恰相反，它是使用输入的内存地址减去ASLR偏移值来得到文件偏移，代码如下。
```

```
def FileOffset(debugger,command,result,result,internal_dict):
  """
  计算文件偏移
  """
  # command = command.strip()
  address = shlex.split(command)[0]
  if not address:
    print>>result,'please input the address!'
    return
  aslr = get_ASLR()
  if address[0:2] == '0x':
    address = int(address,16)
  else:
    address = int(address)
    
  offset = address-int(aslr,16)
  print>>result,("FileOffset:0x%.8x"%offset)
```

#### 3. 向调试器添加命令

```
3.向调试器添加命令
上面两步已经完成了命令函数的编写，但这样还不能提供给LLDB交互界面使用，需要先添加一下才可以。
此过程涉及一个__lldb_init_module函数，这是脚本的入口，其中可以添加各种初始化代码：
  def __lldb_init_module(dubugger,internal_dict):
        dubugger.HandleCommand('command script and -f pyg.BP bp')
        dubugger.HandleCommand('command script and -f pyg.FileOffset foff')
代码中的“pyg”是脚本名称（要和保存脚本的名称一致），
“BP”是第1步添加的断点名称，后面的“bp”是对调试器添加的命令名称。
```

#### 4. 将脚本加载到 LLDB

```
4.将脚本加载到LLDB
将脚本加载到LLDB只需要一行代码，若是临时加载，则在LLDB交互界面中输入
“command script import～/.lldb/pyg.py”即可，
若要启动时自动加载，则将这句代码写入～/.lldbinit文件。
然后就是测试脚本功能了，具体如下。

bp 0x00000000100868B50
c

po $x0
x/s $x1
foff 0x10089cb50

help bp
  超级断点-自动处理ASLR
help foff
  计算文件偏移
  
除了自己编写脚本外，还有一些第三方的开源脚本，如Chisel等，将在下一小节的高效技巧中进行讲解。
```

### 7.1.6 LLDB 高效技巧

```
7.1.6 LLDB高效技巧前面介绍的基本调试是一些比较通用的方法，除此之外，大家还应该学习和掌握LLDB的一些高效技巧，这样才能从容应对各种复杂的调试。
本小节将介绍一些在实际分析中使用较多且能提高分析速度的常用技巧。
```

#### 1. 给断点添加命令

```
1.给断点添加命令假设有个解密函数被调用了100次，现在需要记录每次传入此函数的值，其常规做法是：对该函数添加断点，断点触发后查看寄存器。
这样当然是没有问题的，但是需要重复做100次。
给断点添加命令就可以让LLDB自动完成这些事情。

下面继续以iThunder的登录方法为例，给断点添加命令。
break list

breakpoint command add 1
po $x0
x/s $x1
po $x2
po $x3
c
DONE

c

首先列出所有断点，找出需要添加命令的编号（此处为1），

然后使用“breakpoint command add 1”输入命令。
这里打印了x0～x3寄存器的值，输入完成后用DONE结尾。
这样在每次函数中断时，系统会按照指定的命令自动打印出数据。
```

#### 2. 使用 Chisel 增强 LLDB 调试

```
2.使用Chisel增强LLDB调试
Chisel是Facebook开源的LLDB命令行脚本，它为LLDB提供了新增的便捷命令，
如果想快速调试iOS程序，不妨学习一下。
首先使用brew安装Chisel，然后将fblldb.py的全路径添加到～./lldbinit，
即可让LLDB启动时自动加载它：

brew install chisel
cat ~./lldbint
...
command script import /usr/local/opt/chisel/libexec/fblldb.py

Chisel提供了非常多的实用命令可用于开发调试，也可用于逆向分析，笔者仅抽取一些用得最多的命令进行介绍。
● pviews：该命令打印当前视图的层次结构，和Cycript的[[UIApp keyWindow]recursiveDescription].toString()功能类似。
● presponder：该命令按照倒叙方式打印某个控件的消息响应链，方便大家了解消息是如何传递的
● pactions：该命令用于打印控件的响应事件。

● pclass：该命令用于打印某个类的继承关系。

● show/hide：该命令用于显示/隐藏某个视图，相当于调用了setHidden:方法。之前在Cycript定位按钮的时候就利用了“隐藏法”来确定，现在只需要用这两个命令就可以了，相当方便。

● methods：该命令用于临时查看某个类的所有方法和内存地址。
● search：该命令用于搜索某个实例对象，类似于Cycript中的choose功能。
● bmessage：该命令对方法名设置断点。如果某个方法在当前类没有实现，而是父类实现的，用常规断点会无效，bmessage有效避免了这种缺陷。
● pdata：该命令用于打印NSData的数据。
```

7.2 IDA 动态调试
------------

```
7.2 IDA动态调试IDA从6.95版开始，加入了iOS远程调试插件，允许用户调试iOS应用，支持ARMv7和ARM64架构。
该插件支持iOS 9～iOS 11版本系统。
调试简单程序的话，用IDA是个不错的选择，起码可以少输入一些命令，查看调用栈、内存等都比较方便。

读者或许还记得，在静态分析的章节，对最终的一个C函数留下一个疑问。
本章仍然选用UnCrackable_Level1作为示例，详细讲解IDA直接启动调试及远程附加调试的过程，解答上面的问题。

需要先说明一下：无论是IDA动态调试还是Xcode动态调试，都需要被调试的应用具备get-task-allow权限；如果没有此权限，请读者参照前面章节自行添加。
```

### 7.2.1 直接启动调试

```
在用IDA调试应用之前，需要先将目标程序拖入IDA中等待反汇编完成，
然后单击“Debugger”→“Select debugger”菜单项，在弹出的对话框中选中“Remote iOS debugger”单选按钮，单击“OK”按钮，如图7-11所示。
在IDA中找到“-[ViewController viewDidLoad]”方法，因为前面的静态分析得出，正确的序列号经过sub_1000080D4子函数得到，所以在它的下一行（即0x0000000100004438地址处）添加断点，以便拿到x0的值。
添加断点的方法为在该行前面的小圆点处单击，此时会呈现红色高亮状态，说明添加成功，如图7-12所示。

此时还需要设置被调试文件的路径。
先在设备上运行目标程序，查询其安装路径：
  ps -ax | grep UnCrackable\ level\ 1
  
现在将目标程序关闭，在IDA中依次单击“Debugger”→“Process option”菜单项，在弹出的对话框中设置刚刚查询到的路径，并单击“OK”按钮，如图7-13所示。

接下来给调试器添加符号路径，Xcode的符号文件存放在～/Library/Developer/Xcode/i OS DeviceSupport/<iOS version>/Symbols目录下。

依次单击“Debugger”→“Debugger options”→“Set specific options”菜单项，在弹出的对话框中，根据被调试设备的版本填写对应的符号路径，如图7-14所示。

到这里为止，所有准备工作就做好了，现在单击工具栏上的按钮或者按〈F9〉快捷键启动程序，过一会儿就会停在断点处，同时发现IDA已经自动处理了ASLR。
此时在“Hex View-1”窗口按快捷键〈G〉，输入“x0”，即可跳转到x0指向的内存，正确的序列号“i am groot!”被清晰地展现出来，如图7-15所示。

接下来的调试过程和LLDB一样，只是快捷键不同而已，笔者不再详述。

IDA调试相关的快捷键可以在“Debugger”菜单下看到。
静态分析一章所学的修改字节的方法，在这里依然有效。
现在转到“Hex View-1”窗口，将正确序列号改为“PYGiOSReBook”，如图7-16所示。

开目标程序，输入修改后的序列号，验证通过，说明内存修改是有效的。
```

### 7.2.2 远程附加调试

#### 1. 移植 vmmap

```
7.2.2 远程附加调试
1.移植vmmap
IDA远程附加进程后，不能列出被附加程序的模块信息，因此得不到ASLR信息，自然就不能添加断点了。

在macOS上有个vmmap命令行工具可以查看模块加载信息，但它并不支持iOS，所以需要移植到iOS上。
具体如下。

下载源文件并经编译、签名后上传到iOS设备的/usr/bin目录：

wget https://github.com/comex/myvmmp/blob/master/myvmmap.c
xrun -sdk iphones clang -arch arm64 ./vmmap.c -o vmmap
ldid -Sent.xml vmmap
scp -P 2222 vmmap root@localhost:/usr/bin
chmod +x /usr/bin/vm

其中，ent.xml文件可以复用debugserver的，此处不再列举。
当然，如果读者不想移植vmmap，则可以使用第5章的Frida脚本函数findBaseAddress()来一键获取。
```

#### 2. 修正加载地址

```
2.修正加载地址在设备上获取目标程序的进程ID，然后执行vmmap命令来获取模块的加载信息，如图7-17所示。
 ps -ax | grep /UnCrackable\ level\ 1
 vmmap 2083 | grep Uncredited ackable -B 1
 
由vmmap执行结果可知，目标程序加载地址为0x10007c000，
依次单击IDA的“Edit”→“Segments”→“Rebase program”菜单项，在弹出的对话框中修正镜像基址，然后单击“OK”按钮，如图7-18所示。
```

#### 3. 开始调试

```
和LLDB一样，需要先在iOS设备上运行debugserver，并监听端口：
 debugserver *:8888 -a 2083
单击“Debugger”→“Select debugger”菜单项，在弹出的对话框中选中“RemoteGDB debugger”，
然后单击“OK”按钮，如图7-19所示。

然后单击“Debugger”→“Process option”菜单项，在弹出的对话框中设置被调试设备的IP和端口信息，并单击“OK”按钮，如图7-20所示。

在修正后的“-[ViewController buttonClick:]”方法内部序列号合法性判断处添加断点，如图7-21所示。

按〈F9〉键继续运行，输入序列号“123456789”，此时断点触发，w24的值为0（条件不满足），在右边双击x24寄存器，修改其值为1（条件满足），再按〈F8〉键单步调试，发现流程已经改变，代码执行到了0x0000000100080580处，如图7-22所示。

接下来当然就是序列号正确的提示了。
```

7.3 Xcode 动态调试
--------------

```
LLDB为Xcode提供了底层调试环境，其中包括内嵌在Xcode IDE中位于调试区域的控制面板，在这里可以直接调用LLDB命令。

使用Xcode动态调试第三方应用具有很多优点，比如，能直观地查看调用栈、内存中的所有对象和对象之间的引用关系，以及借助“Debug View Hierarchy”这一强大功能直接查看应用的界面布局等。
```

### 7.3.1 远程附加调试

```
7.3.1 远程附加调试Xcode的附加调试功能简单易用，任意新建一个工程，依次单击“Debug”→“Attach to Process”菜单项，选择需要调试的进程，

或使用“Attach toProcess by PID or Name”菜单项，在弹出的对话框中直接输入进程ID或者进程名进行附加，如图7-23所示。

附加成功后，底部的调试区域会出现图7-24所示的按钮，单击第三个按钮使程序暂停（也可以单击“Debug”→“Pause”菜单项）。

待程序暂停后，
在“-[XLMemberManagerloginByUserName:password:verifyCode:verify Key:finishBlock:]”方法上添加断点，文件偏移为0x0000000100868B50。
这里使用前面编写的脚本命令bp进行添加，然后输入“c”继续运行，在登录界面输入相关信息后，断点被触发，之后就可以进行查看寄存器参数等操作了，如图7-25所示。

笔者最喜欢使用左边的调用栈显示功能（如果没有展开，则单击界面左栏下方的对应按钮即可）。单击某个序号，还可以跳转到相应的调用处，如图7-26所示。

此外，在断点触发后，Xcode还可以查看当前加载的所有模块信息，比如单击“Debug”→“Debug Workfow”→“Shared Libraries”菜单项进行查看，如图7-27所示。

如果要查看内存数据，只需单击“Debug”→“Debug Workfow”→“View Memory”菜单项，然后输入指定地址即可，如图7-28所示。
```

### 7.3.2 直接启动调试

```
7.3.2 直接启动调试
Xcode直接启动调试程序还是比较麻烦的，需要对被调试应用进行重签名、打包等。本节化繁为简，利用一些小技巧使得调试过程尽量简洁一些。

（1）新建同名空白工程
    使用Xcode新建一个与被调试程序同名的空白工程。
    单击菜单项“File”→“New”→“Project”，在弹出的对话框中选择“iOS”→“Single View App”，并命名为“UnCrackable Level 1”，如图7-29所示。
    接着在工程同级目录下新建Target/Payload文件夹，将待调试的.app文件复制到该目录，此时目录结构如下。

（2）添加自定义脚本
    在Xcode的构建阶段可以添加自定义运行脚本，以根据项目需求改变构建流程。
    单击“Build Phases”标签，再单击左上角的加号按钮，选择“New Run ScriptPhase”命令，在脚本框中输入如下内容。
    cp -rf "${SRCCROOT}/Target/Payload/UnCrackable Level 1.app" "$BUILT_PRODUCTS_DIR"
    
    完成后如图7-30所示。
    
    该脚本利用了“偷梁换柱”的小技巧，首先将第三方应用复制并替换为新建工程生成的文件，然后利用Xcode自动对替换后的第三方应用使用证书进行签名，最后将签名后的应用安装至iOS设备上。
    这就是第一步要新建同名应用的原因。
    
（3）添加符号断点
    Xcode提供了符号断点功能，可以针对某一个方法或函数设置断点并暂停执行，以跟踪获取该方法或函数的调用栈。
    现在的问题是：目标文件没有恢复符号表（7.3.3节会讲解恢复符号表），所以无法对“-[ViewController viewDidLoad]”方法添加符号断点。
    
    但是可以变通一下，程序的入口点main函数里面有一个UIApplicationMain函数，这时可以先对它添加断点。
    单击Xcode界面左边的箭头按钮，再单击左下角的加号按钮，选择“Symbolic Breakpoint”命令，如图7-31所示。
    在弹出对话框的“Symbol”文本框中输入需要添加断点的符号（这里是“UIApplicationMain”）。
    若单击“Add Action”按钮，则可以添加断点触发后要执行的操作。
    若勾选“Automatically continue after evaluating actions”复选框，则断点触发后会让程序继续运行，如图7-32所示。
    此时单击Xcode的运行按钮，被调试程序会被安装到iOS设备上，过一会儿就会触发符号断点，此时程序执行流程就被调试器接管了，可以使用命令对“-[ViewController viewDidLoad]”的偏移地址添加断点，如图7-33所示。
```

### 7.3.3 恢复符号表

```
在用IDA分析二进制文件的时候，明明看到的是方法或函数名称，怎么在LLDB调试的时候就看不到了呢？
而且每次都手动计算偏移才能添加断点很麻烦。
其实这是因为LLDB找不到符号表与偏移的对应关系。
既然IDA能看到，说明二进制文件本身已经包含了这些符号，想办法分析Mach-O文件，并将其恢复即可。
GitHub上已经有开源工具实现了这个功能，下载并编译该源码得到restore-symbol可执行文件，具体如下。
  git clone --recursive http://github.com/tobefuturer/restore-symbol.git
  cd restore-symbol && make
```

```
（1）恢复方法名
 使用编译好的restore-symbol工具对iThunder的二进制文件进行方法名恢复，具体如下。
   lipo -thin arm64 iThunder -output iThunder64
   ./restore-symbol iThunder64 -o iThunder_with_symbol
 因为restore-symbol不支持多架构，所以先用lipo提取ARM64架构到iThunder64再进行操作。
 
（2）恢复block符号
    Restore-symbol工具还支持block（代码块）符号恢复，需要配合IDA的脚本先生成一份JSON数据，单击“File”→“Script file”菜单项，选择/restore-symbol/search_oc_block/ida_search_block.py文件，如图7-34所示。
    执行完毕后会生成一个block_symbol.json文件，里面是各个block函数与符号表描述信息，如图7-35所示。

    使用restore-symbol工具的-j参数将上述文件加入，就能恢复block符号了，具体如下。
    ./restore-symbol iThunder64-o iThunder_with_symbol -j block_symbol.json
    再次用IDA反编译iThunder_with_symbol，然后与还原前的结果比对，可以看到明显的区别，对比效果如图7-36和图7-37所示。
    将处理后的文件上传到设备（如果闪退就先用FixMachO工具修复），替换原来的可执行文件。再次使用Xcode或者LLDB附加调试，使用符号名设置断点（也可以使用Xcode的添加符号断点功能）：
    断点触发后能够看到完整的带符号调用栈，看起来清晰了许多，如图7-38所示。
    通过本节可以看到，恢复符号表后，在调试时就能直接在调用栈中看到方法名，免去了计算偏移量然后在IDA里查找的麻烦。
```

### 7.3.4 UI 调试功能

```
UI调试功能
  Xcode自带的“Debug View Hierarchy”功能，用途和Reveal工具一样，都是用来调试UI。
  它可以让开发者在程序运行状态下动态查看当前页面的显示情况，包括视图层次、控件大小和位置，而且可以用3D效果展示当前视图的层次等。
  虽然此功能是给开发者提供的，但是前面已经把第三方应用载入Xcode来进行动态调试了，自然也能体验这个高级功能。以微信为例。先进入登录页面，单击Xcode调试栏中的“Debug View Hierarchy”按钮，如图7-39所示。
 此时程序会中断，等待刷新完毕后，会展现当前被调试的页面，如图7-40所示。
 
 在左侧窗口底部的过滤文本框中输入关键字可以快速匹配所有符合条件的控件。
 单击某个感兴趣的控件，详细信息都会在右边展示。例如，笔者选择了“找回密码”按钮，除显示一些常规属性外，还显示了该按钮的内存地址，甚至直接把按钮响应事件都分析出来了，这为定位目标函数提供了极大的方便，如图7-41所示。
 
 配合调试栏的LLDB命令，可以快速测试某个功能，就像在使用Cycript一样。以单击“找回密码”按钮为例，操作如下。
 po [0x14e564510 setHidden:YES]
 search WCAccoundMainLoginControlLogic
 po [0x14e2d3940 onMainLoginProblem]
 c
 
 使用“Debug View Hierarchy”功能，可以不借助任何第三方工具来分析UI，减少了很多不必要的操作，读者在实际调试中可以将它作为一种备选方案。
```

7.4 本章小结
--------

```
本章详细讲解了LLDB从配置到建立连接再到调试的过程，还穿插了手动脱壳、脚本开发及高效技巧等细节。
LLDB功能的强大是毋庸置疑的，只是由于没有图形界面而不太被入门者接受，因此本章后面介绍了使用IDA及Xcode的图形化方式来辅助调试以提高效率，读者可以根据实际调试环境和个人习惯选择最合适的调试方式。
```

第 8 章 越狱开发
==========

```
通常意义上的越狱开发，是指开发一个插件、命令行工具或者系统应用，它们最终以deb的方式提供，
这些deb文件可以加到源里面通过越狱商店进行安装，或直接发给别人用命令行或图形工具安装。

越狱开发属于iOS逆向工程必备的技能，它可以用来测试函数调用、修改系统配置、去除应用广告、扩展应用功能以及破解应用限制等。
```

8.1 Theos 简介
------------

```
Theos是一个跨平台的越狱开发工具包，可以在Windows、Linux、macOS甚至iOS下工作。
Theos无论是下载安装还是编译发布都比较简单，它为开发者准备好了一些代码模板、预置了一些基本的Makefile脚本，这样开发一个插件就会变得方便很多，其Logos语法也是相当优雅，让开发者可以更专注于功能开发。
Theos相当于对Cydia Substrate的封装，因而能实现对Objective-C运行时的Hook，也能实现对C语言函数的Hook。
```

### 8.1.1 Theos 安装

```
1.安装ldid在Theos开发中，iOS文件的签名由ldid工具来完成，
  ldid取代了Xcode自带的codesign。使用brew安装即可：
  brew install ldid
  
2.安装xz、lzma
  xz、lzma是两种压缩模块，为了后面“make package”能够顺利通过，需要安装它们。安装方法如下：
  brew install xz
  sudo cpan IO:Compress:Lzma
这一步由于网络原因可能耗时会有点长，请耐心等待。

3.添加$THEOS环境变量读者可以使用任何编辑工具打开.bash_profile文件，
  添加下面的环境变量：
  export THEOS=/opt/theos
  export PATH=$PATH:$THEOS/bin
4.安装Theos使用root权限从GitHub下载源代码后安装到$THEOS目录即可，具体如下：
  sudo git clone --recursive https://github.com/theos/theos.git $THEOS
5.设置$THEOS的用户组权限
  sudo chown -R ${id -u}:$(id -g) $THEOS
最后执行$source～/.bash_profile使配置生效。
```

### 8.1.2 Theos 常用模块

```
Theos安装配置完毕以后，打开终端输入“nic.pl”，启动NIC（New InstanceCreator），输出内容如下：
 nic.pl

可以看到当前版本的Theos有14种工程模板可供选择，笔者经常使用的只有以下4种：
● tweak：插件模板。
● tool：命令行工具模板。
● application：系统级应用模板。
● xpc_service：XPC服务模板。

接下来将按此顺序逐个进行详细讲解。
```

8.2 插件开发
--------

```
iOS越狱平台下的插件称为“tweak”，各种越狱插件的集合统称为“tweaks”，
它的实质就是iOS平台的动态库（dylib），利用Cydia Substrate提供的组件进行加载，完成特定的功能。
插件是iOS越狱开发中使用频率最高，也最容易上手的模块。
本节仍然以读者比较熟悉的iThunder登录方法为例进行讲解。
```

### 8.2.1 创建工程

```
打开终端输入“nic.pl”，在工程模板选项中输入“13”并按〈Enter〉键，创建一个tweak工程：

对一些配置参数介绍如下。
● Project Name：项目名称（必须填写）。
● Package Name：插件的包名（默认是com.yourcompany.projectname）。
● Author/Maintainer Name：插件作者（默认是当前登录用户名）。
● MobileSubstrate Bundle filter：被注入应用的BundleID，需要打开被注入应用的Info.plist查看（默认是com.apple.springboard）。
● applications to terminate：安装成功后需要结束的进程（默认是SpringBoard），如果不需要结束任何进程，请输入“-”。
经过上述配置，一个名为“iThunderHelper”的tweak工程就生成了。
```

### 8.2.2 解读工程文件

```
Theos生成的tweak工程文件非常简洁（仅4个文件），目录结构如下：

Theos这种化繁为简的工程架构总是给人一种亲切感，不至于让初学者摸不着头脑。
  1.Makefile
  2.Tweak.xm
  3.control
  4.iThunderHelper.plist
```

```
1.Makefile
  对于熟悉Linux开发的读者来说，Makefile应该是老朋友了，它几乎无处不在。
  Makefile指定了该工程用到的源文件、框架、库等信息，关系到整个工程的编译规则，带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程就会完全自动编译，能够极大地提高开发效率。
  iThunderHelper的Makefile内容如下：

下面按编号详细解读其内容。
①：引入Makefile的公共文件，为固定写法，无须修改。
②：创建工程时指定的“Project Name”内容，不要修改。
③：tweak包含的源文件（头文件除外），多个文件用空格分开，如“iThunderHelper_FILES=Tweak.xm ANYMethodLog.m PYG.m”。
④：根据不同的工程类型指定.mk文件，这里新建的是tweak工程，所以填入的是tweak.mk文件，还可以填入application.mk及tool.mk等。
⑤：指定安装插件后需要执行的操作，这里是结束iThunder进程，方便iThunder重新启动时加载对应的动态库。

以上是Makefile的默认内容，除此之外，还有一些额外的配置，需要用到的时候再做介绍。如果读者迫不及待地想编译一下，请在终端输入make命令，没错误时即可进入下一步。
```

```
2.Tweak.xm

这是默认生成的源文件，“.xm”后缀表示源文件支持Logos和C/C++语法，如果后缀为“.x”，说明源文件仅支持Logos和C语法。

这同“.m”和“.mm”后缀的区别类似。
此外，还有“.xi”和“.xmi”两种后缀，由于用得极少，就不做详细介绍了。

先从class-dump导出的头文件里面找到登录方法的定义：

打开Tweak.xm文件删除原内容，修改如下：

CDUnknownBlockType是未知类型，可以用“万能”的“id”类型代替。
除此之外，还出现了一些“%”开头的内容，其实这就是Logos语法的预处理命令，下面分别进行介绍。

（1）%hook
指定需要Hook的类名，接着就是需要Hook的函数，最后必须以%end结尾。

（2）%log
该命令在%hook内部使用，将类名、函数名、参数信息打印出来，非常实用。
需要注意的是只在DEBUG模式下才会输出信息。

（3）%orig
该命令在%hook内部使用，执行被Hook函数的原始代码。
如果不调用%orig，则原函数逻辑不会执行。

%orig还可以代入参数执行，例如示例代码可以改为“%orig(@"piao",@"11223344", arg3, arg4, arg5);”，这样就把用户名和密码分别替换成了“piao”和“11223344”。

实际上，除了上面代码中的%hook、%log、%orig以外，还有一些常用的预处理命令，下面逐一进行介绍。

（4）%new
该命令在%hook内部使用，为现有类增加新的方法，功能与class_addMethod相同。示例如下：
 %hook XLMemberManager
 %new
 -(void) newMethod(
   NSLog(@"newMethod for ViewController");
 )
 %end
 
 如果尝试用[self newMethod]调用这个方法，在编译时会得到“error: instancemethod '-newMethod' not found”的错误，这时只要添加一个newMethod的定义，骗过编译器即可，
 如下：

@interface XLMemberManager
-(void) newMethod;
@end

（5）%c
该命令在%hook的内部使用，用于动态获取一个类的定义，与objc_getClass和NSClassFromString等效，示例如下：

（6）%group
该命令用于将%hook分组，便于代码管理及按条件初始化，必须以%end结尾。
一个%group可以包含多个%hook，所有没有分组的%hook都会被隐式归类到%group_ungrounped中。

这段代码的意思是
在 %group iOS9Hook中Hook类iOS9Class的iOS9Method方法，
在 %group iOS8Hook中Hook类iOS8Class的iOS8Method方法，
然后在%group_ungrounped中Hook类otherClass的otherMethod方法。
需要注意的是，%group必须配合接下来的的%init命令才能生效。

（7）%init该命令用于初始化某个%group，可以在%hook和%ctor内调用。
若带参数，则初始化指定的group，否则初始化_ungrouped。具体如下：

（8）%ctor该命令是tweak的构造函数，一般用来初始化%group，以及进行MSHookFunction等操作。
如果不写，Theos就会自动生成一个隐式%ctor并在其中调用%init(_ungrouped)。具体如下：

（9）%hookf该命令给指定的函数生成Hook，实则是对MSHookFunction()函数的包装。其格式如下：
      
    symbolName可以传入函数地址或者函数符号，先看传入地址的例子：

    如果将symbolName作为字符串传入，那么函数将被动态查找，示例如下：

    关于Logos的预处理指令有很多，但有些并不常用，感兴趣的读者可以到     
    http://iphonedevwiki.net/index.php/Logos查看详情。
```

```
3.control
 control文件是deb包必备的文件，它记录了deb包管理系统所需的基本信息。iThunderHelper工程里面的control文件内容如下：

对其中一些配置参数的介绍如下。
● Package：描述deb包的唯一ID，和BundleID类似，通常用反域名命名规则，可修改。
● Name：描述tweak的名字，可修改。
● Depends：描述deb包的依赖项。
  “依赖”是指运行程序所具备的基本条件。
  多个依赖使用逗号隔开，如果指定版本号则在后面用括号标注，例如，“mobilesubstrate, com.rpetrich.rocketbootstrap (>=1.0.2)”表示当前iOS设备必须安装mobilesubstrate框架及1.0.2以上版本的rocketbootstrap组件才能正常运行。可修改。
● Version：描述deb包的当前版本，可修改。
● Architecture：描述deb包的架构，在iOS中恒为“iphoneos-arm”，不可修改。
● Description：对tweak的简要描述，可修改。
● Maintainer：描述deb包的维护人员，可修改。
● Author：描述tweak的开发者，可修改。
● Section：描述deb包的所属类别，可修改。

以上是一个最基本的control文件所具备的字段，非特殊情况，无须修改它。
```

```
4.iThunderHelper.plist
这个plist文件里面记录了一些配置信息，Cydia Substrate会按照它指定的规则注入相关程序。可以用Xcode或Sublime Text打开它进行查看或修改，如图8-1所示。


Filter作为过滤器，有四种过滤规则。● CoreFoundationVersion：根据CoreFoundation.framework的版本号进行过滤。● Bundles：根据应用的BundleID进行过滤。● Classes：根据应用是否实现了某些特定的Objective-C类来进行过滤。● Executables：根据可执行文件名称进行过滤。
```

### 8.2.3 编译 + 打包 + 安装

```
前面已经创建了第一个tweak工程，且对文件结构进行了一些讲解，现在开始编译、打包和安装过程。
```

```
1.编译
在工程目录下运行make命令，从输出日志看到，Theos完成了预处理、编译、链接、签名的一系列动作。
  ~/path/to/ithunderhelper
  make
编译生成的dylib文件保存在.theos/obj/debug/文件夹下，可以复制出来单独使用。
 cd .theos/obj/debug
 ls -al

arm64和armv7文件夹里面分别有相应架构的dylib文件，而外层的iThunderHelper.dylib则是将所有架构合并后的产物。

目前ARMv7架构已经淘汰了，而且从iOS 11系统开始已经完全禁止32位程序的运行，所以多架构合并已经没有意义，可以通过Makefile定制一些配置来进行处理。

（1）指定处理器架构
 支持的类型：
   i386 x84_64 arm64 armv7 armv7s armv7f armv7v arm64 arm64e
  示例：
   ARCHS=arm64arm64e

（2）指定目标规范
  格式：
       platform:compiler:sdk_version:deployment_version
  示例：
       TARGET=ipone:clang:10.2.8.0

  该示例的意思是：指定目标平台为iOS，指定编译器为clang，使用10.2版本的SDK编译该tweak，且编译后的程序只能在8.0及以上的系统运行。
  通常情况下该语句会省略编译器类型，并把SDK版本设置为“latest”，表示使用最新版Xcode提供的SDK编译，具体如下：
       TARGET = ipone:latest:8.0

（3）指定编译模式
  tweak的默认编译模式是debug，如果想要改为release要怎么办呢？
  只要指定DEBUG=0即可，除了可以加在Makefile里面，还可以加在make命令前（笔者偏好于此方法），具体如下： 
   ～/path/to/ithunderhelper
    DEBUG=0 make

这样就按照指定配置生成了一个release模式下的ARM64架构dylib文件。
```

```
2.打包
  使用Theos自带的“make package”命令进行打包时，会先执行make命令，然后再执行dpkg-deb命令，如下：
  ~/path/to/ithunderhelper
  DEBUG=0 make package
  这样就在./packages目录下生成了一个名为“com.chinapyg.ithunderhelper_0.0.1-1_iphoneos-arm.deb”的deb包，这就是最终可以发布的安装包。
```

```
3.安装
  deb包的安装方法多种多样，这里介绍两种典型的方法：图形界面安装和命令行安装。
  （1）图形界面安装图形界面安装主要针对非开发人员，通过PP助手等工具把deb包传到指定的目录（笔者习惯将它传到tmp目录，方便操作），然后用Filza找到该deb包，单击进入文件详情界面，再单击右上角的“安装”按钮即可，如图8-2所示。
  打开Cydia，打开“已安装”选项卡，会看到刚才安装的“iThunderHelper”。
  
  （2）命令行安装图形界面的交互过于烦琐，对于开发人员来说，命令行才是最好的归宿。
  其实用命令行安装又分为两种，下面逐个讨论。在本部分中，假设读者都已经配置好SSH，如果对这部分知识不了解，请先阅读第2章。
  
  ● 利用dpkg手动安装
  将“com.chinapyg.ithunderhelper_0.0.1-1_iphoneos-arm.deb”文件用scp传输到iOS设备的/tmp目录，然后使用dpkg命令安装，具体如下：
  #由于已经做了端口映射，所以直接用localhost和2222
  #复制文件到ios设备
  scp -P2222 com.chinapyg.ithunderhelper_0.0.1-1_iphoneos-arm.deb root@localhost:/tmp/
  com.chinapyg.ithunderhelper_0.0.1-1_iphones-arm.deb
  #登录ios设备
  ssh -p 2222 root@localhost
  #进入/tmp目录
  cd /tmp
  #执行安装
  dpkg -i com.chinapyg.ithunderhelper_0.0.1-1_iphones-arm.deb


  ● 利用Theos安装
  本方法是最快捷的，它使用Theos提供的“make package install”命令进行安装。
  1）需要修改Makefile文件，配置IP和端口。
     THEOS_DEVICE_IP = localhost
     THEOS_DEVICE_PORT = 2222
  2）输入“make package install”命令，完成从编译到打包再到安装的整个过程。
     DEBUG=0 make package install

  现在激动人心的时刻到了，打开macOS控制台，在iOS设备上启动iThunder，输入信息并登录，插件成功截获了相关参数并打印出日志，如图8-3所示。
  
  至此，第一个越狱插件就开发成功了。
```

8.3 命令行工具开发
-----------

```
Theos提供的tool模板用来编写命令行工具。
命令行工具的权限通常都很高，所以能做很多特别的事情，Cydia Substrate自带的cynject工具就是一个典型的例子。
本节编写一个简单的小工具，根据输入的进程名查找PID（效果等同于“ps-ax|grepxxxx”）。
```

### 8.3.1 创建工程

```
在选择模板的时候，输入“11”，创建一个名为“FindProcess”的tool工程，接下来的步骤和tweak类似。
现在打开main.mm文件，修改代码（完整代码见随书附件）：

由于使用了纯C代码，所以输入make命令直接进行编译会出现错误，需要将main.mm重命名为“main.c”，
同时修改Makefile中的“findprocess_FILES”一行，顺便把其他配置加上，方便后续打包。

具体如下：
  THEOS_DEVICE_IP = localhost
  THEOS_DEVICE_PORT = 2222
  ARCHS = arm64
  TARGET = iphone:lastest:8.0
  
  include $(THEOS)/makefiles/common.mk
  
  TOOL_NAME = findprocess
  findprocess_FILES = main.c #将这里main.mm改为main.cc
  
  include $(THEOS_MAKE_PATH)/tool.mk
  
接着输入“DEBUG=0 make package install”，将命令行工具安装到设备，测试效果如下：
   findprocess WeChat
```

### 8.3.2 兼容 iOS 11～iOS 13

```
如果将8.3.1节编译的程序放在iOS 11～iOS 13系统运行，可能会出现“killed:9”的错误，这时需要按如下方式处理。

1）新建ent.xml文件，内容如下：
<?xml version = "1.0" encoding = "UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
 <dict>
   <key>platform-application</key>
   <true/>
 </dict>
</plist>

2）修改Makefile，配置CODESIGN_FLAGS参数，如下：
  findprocess_CODESIGN_FLAGS = -S./ent.xml

3）修改安装路径（不是必须的），命令行工具默认安装到/usr/bin目录，该路径也是可以修改的，配置INSTALL_PATH参数即可：
  findprocess_INSTALL_PATH = /bin
 
重新编译安装后，可以在Cydia里面看到路径被改为“/bin”了，如图8-4所示。

在笔者的iPhone XS Max（iOS 12.1.2）中测试结果如下：
  findprocess WeChat
```

8.4 系统级应用开发
-----------

```
Theos提供的application模板用来开发系统级应用（比如NetTerm 2、Filza等），
这些应用安装后会在桌面上显示一个图标，和App Store下载安装的应用一样，不过它们的权限更高，且无法通过常规方式删除。
```

### 8.4.1 创建工程

```
在选择模板的时候，输入“2”，
创建一个名为“PYGiOSReBookApp”的application工程，具体如下：

这里的工程选项出现了一个“Class name prefix”，这是类名前缀。生成后的文件如下：

这次生成的文件比较多，其中的Resources文件夹保存的是资源文件（包括程序中需要使用的图片和Info.plist文件），之后将会把这些资源和可执行文件一起打包成deb文件。

将PYGRootViewController.m文件的内容删除，添加如下代码：
  这段代码在当前视图正中间添加一个“Test”按钮，单击该按钮，先获取进程权限，
  然后尝试打开keychain的数据库。
  由于使用了sqlite3，所以需要修改Makefile，增加XXXX_LDFLAGS参数将其链接进来，具体如下：

“after-install”配置的是deb文件安装之后执行的命令，
  第1条执行uicache更新缓存，使桌面图标显示出来，
  第2条命令结束PYGiOSReBookApp进程。
  
输入“DEBUG=0 make package install”编译并安装到设备，启动PYGiOSReBookApp，单击“Test”按钮，日志如下：

  可以看到getuid()和geteuid()都返回了501（mobile权限），
  下面的代码自然就执行失败，打开数据库返回了14。
  下一步就是对PYGiOSReBookApp提升权限，使其得到root权限。
```

### 8.4.2 以 root 权限运行（iOS 11 以下）

```
众所周知，在Linux下可以使用setuid(0)及setgid(0)提升权限，那在iOS中行不行得通呢？来试一下。打开main.m，修改代码如下：

编译并安装后，启动程序直接闪退，这是因为backboardd以mobile权限运行，不能加载要求root权限的程序：
  ps aux | grep backboardd
 
换句话说，这个崩溃是好事，说明已经提升成功了。
对于iOS 11以下的系统处理方法稍微复杂，具体如下：

1）在Resources目录下新建loader文件，写入以下代码：
  #!/bin/bash
  root=${dirname "$0"}
  exec "${root}" /PYGiOSReBookApp

2) 修改Resource目录下的Info.plist
将“CFBundleExecutable”由“PYGiOSReBookApp”改为“loader”，如下：
cat Resource/Info.plist
<plist version = "1.0">
 <dict>
  <key>CFBundleExecutable</key>
  <string>loader</string>
 </dict>
</plist>

这两个步骤使程序运行时先执行loader（mobile权限），然后由loader来加载PYGiOSReBookApp。

3）修改Makefile：
 after-stage::
   $(ECHO_NOTHING)chmod +s $(THEOS_STAGING_DTR)/Applications/PYGiOSResourceApp.app/PYGiOSReBookApp$(ECHO_END)
   
这一步的作用是给安装后的PYGiOSReBookApp文件添加suid权限。
重新编译并安装，运行结果如下：
```

### 8.4.3 以 root 权限运行（iOS 11、iOS 12）

```
在iOS 11和iOS 12中的权限提升其实更加简单，通过https://github.com/coolstar/electra/blob/master/docs/getting-started.md文档可知，
只需要在setuid(0)之前调用/usr/lib/libjailbreak. dylib中的jb_oneshot_fix_setuid_now函数即可，
该动态库由Electra、Chimera越狱工具提供。具体示例如下：

还要特别注意在ent.xml文件中添加
platform-application、
com.apple.private.security.no-container及
com.apple.private.skip-library-validation权限，否则运行不起来。

如果在后续开发中遇到闪退问题，请检查是否增加了这三个权限，笔者不再重复。
```

### 8.4.4 以 root 权限运行（iOS 13）

```
如果读者的设备基于checkra1n工具进行越狱（通常是iOS 12.3～iOS 13），
那么只需要使用8.4.2节的main函数代码并在Makefile文件中给主文件添加“+s”标记即可完成提权：
 after-stage::
   $(ECHO_NOTHING)chmod +s $(THEOS_STAGING_DTR)/Applications/PYGiOSResourceApp.app/PYGiOSReBookApp$(ECHO_END)

当然也可以采用8.4.3节的方法，
但是需要预先从其他设备上复制/usr/lib/libjailbreak.dylib文件到目标设备的相同路径下。
```

8.5 守护进程开发
----------

```
守护进程（Daemon）是一个运行在系统后台、不受前台用户交互影响的进程。
通常，守护进程以字母“d”结尾，
例如syslogd是处理系统日志的后台进程，
   afc2d是文件服务的后台进程等。
```

### 8.5.1 创建工程

```
iOS中的守护进程其实就是由一个命令行程序和一个plist文件构成的，
所以使用命令行工具模板新建工程即可。

由于目前还没学习进程间的通信环节，所以本节先编写一个简单的pygiosrebookd守护进程用于演示，它启动时打印一行日志，并往/tmp目录写入pp.log文件后常驻后台。

将main.m的内容修改如下：

编译后安装到iOS设备，此时它仅仅是一个普通的命令行工具，还不具备守护进程的特征，以下步骤将它打造成一个守护进程。

新建com.chinapyg.pygiosrebookd.plist文件，内容如下：

这是一个最简单的plist配置文件，其含义见表8-1。

如果后台进程需要其他的参数，只需要在文件中增加类似下面的键值对即可：

大家知道，iOS的根进程是launchd，它会在开机时检查
/System/Library/LaunchDaemons和
/Library/LaunchDaemons目录下所有符合条件的plist文件，然后启动对应的守护进程。

所以把com.chinapyg.pygiosrebookd.plist文件放到以上任意目录下，输入“reboot”重启设备，会发现pygiosrebookd已经随系统启动，并在/tmp目录写入了文件，符合预期，如下所示：

那么有没有办法在不重启设备的情况下加载plist呢？答案是肯定的。
iOS提供了一个launchctl命令行工具，它用于显示、加载、卸载、启动和关闭守护进程。具体使用方法如下。

（1）获取信息（list）
 launchct1 list

第1列表示进程ID，如果只显示一个横线，说明已经加载，但没有运行；
第2列是上次退出的状态码（0表示成功，正数表示错误退出，负数表示收到信号后退出）；
第3列是守护进程的唯一标识。

所以从上面的结果可以得出com.chinapyg.pygiosrebookd被加载但未启动。

（2）加载/卸载（load/unload）
launchctl load/Library/LaunchDaemons/com.chinapyg.pygiosrebookd.plist
launchctl unliad /LivbraryDaemons/com.chinapyg.pygiosrenbooked.plis

（3）启动/停止（start/stop）守护进程可以加载但不立即启动（将RunAtLoad设置为false），
  适当的时候，可单独启动或者关闭：
  
  launchct1 startcom.chinapyg.pygiosrebooked
  launchct1 list | grep pyg
  launchct1 stop com.chinapyg.pygiosrebookd
  
有关守护进程的详细手册，可以阅读苹果官方的文档，网址：https://developer.apple.com/library/archive/technotes/tn2083/_index.html。
```

### 8.5.2 自动部署

```
经过8.5.1节的处理，一个简单的守护进程就编写好了，但是有个问题，这个过程中需要人工干预来处理plist文件，略显低端。

本节利用Theos的layout功能来完成自动部署。

在工程目录下创建一个名为“layout”的文件夹，Theos在打包时会将其中的内容按照路径添加到deb包中。具体操作如下：
  1）先将com.chinapyg.pygiosrebookd.plist放到layout/Library/LaunchDaemons文件夹内，如下所示：
  2）在layout文件夹内新建DEBIAN文件夹，并将control文件移进来。
  ～/path/to/pygiosrebookd
  mkdir ./layout/DEBIAN
  mv control ./layout/DEBIAN

3）在DEBIAN文件夹中分别新建postinst、preinst及prerm文件，各自内容如下：
  #postinst文件
  #!/bin/sh
  launchctl load/Library/LaunchDaemons/com.chinapyg.pygiosrebookd.plist
  
  #preinst文件
  #!/bin/sh
  launchctl unload /Library/LaunchDaemons/com.chinapyg.pygiosrebooked.plist 2>&1 /dev/null
  
  #prerm文件
  #!bin/sh
  launchctl unload /Library/LaunchDaemons/com.chinapyg.pygiosrebookd.list
  
  这几个脚本文件分别用于deb包安装前后的一些处理，可以看到它们其实是把人工执行launchctl命令的过程使用脚本替代了。
  完成之后的工程目录如下所示。
  
输入“make package”打包后，所有文件已经按照layout的结构打包进去了，读者可用dpkg-deb查看包结构。
利用layout能方便地将所有需要集成的文件统一进行处理，在接下来的章节会大量应用，但后面不会再详细讲解其具体步骤，如果读者还不熟悉，建议反复阅读本小节。
```

8.6 进程间通信
---------

```
进程间通信（IPC）就是在不同进程之间传播或交换信息，后面也简称为“进程通信”。
iOS是相对封闭的系统，由于其沙盒限制，使得进程通信变得困难。
在正向开发中，也只能使用苹果公司提供的URL Scheme，也就是应用之间互相调用并且传送简单字符的一种机制。

但对于越狱开发来说，进程通信的对象往往是各种守护进程，所以这种方式没什么用，因此，探索一些突破沙盒限制的进程通信方法就变得非常有意义。
在本节将会讲解笔者工作过程中常用的几种进程通信方式，它们在越狱环境下能够突破沙盒限制，完成各种“不可能”的操作。
```

### 8.6.1 Notification 通信

```
在CoreFoundation库中有一个系统级的通知中心CFNotificationCenterGetDarwinNotify Center()，iOS自身也在使用它。
大家可以让交互双方各自在Darwin层上建立一个或多个Notification监听，来实现对系统事件或自定义事件的捕获。
之前编写的pygiosrebookd没有任何实际意义，现在将它改动一下，利用另外一个应用来控制它做不同的事情。
修改后的代码如图8-5所示。

上面的代码监听了“com.chinapyg.notification.safemode”通知，由NotificationReceived Callback回调函数负责处理逻辑：收到“com.chinapyg.notification.safemode”通知时会向应用发送“com.chinapyg.notification.app”通知，然后进入安全模式。

同理，在PYGiOSReBookApp端需要监听“com.chinapyg.notification.app”通知才能进行相互通信，主要代码如图8-6所示。

当“Test”按钮被单击时，
利用notify_post()发送“com.chinapyg.notification.safemode”通知，
守护进程收到该通知后触发逻辑，
通过日志可以看到双方的通信过程：

Notification通信方法简单易用，但遗憾的是不能传递userInfo参数（虽然它有一个userInfo参数，但实际上是无法传递的，对方收到的总为“nil”，感兴趣的读者可以自行测试），所以不适合需要传递参数的场合。
接下来讲解的XPC方式可以解决这个问题。
```

### 8.6.2 XPC 通信

```
XPC是macOS下的一种进程间通信技术，它实现了权限隔离，使得应用的沙盒更加完备。

其实XPC在iOS上应用也很很广泛，但是目前只有苹果官方能够使用，也没有系列的文档可以参考。而对于越狱开发，就可以忽略苹果公司的限制，从macOS上将XPC头文件移植过来即可在iOS上使用。

XPC Service由两个部分组成：Service本身，以及与之通信的代码。
它们都很简单而且是相似的。
利用Theos提供的xpc_service模板，创建一个名为“pygxpc”的xpc_service工程，之后将随书提供的xpc_header.zip解压到$THEOS/vendor/include内，使其能直接在工程中使用。

按照图8-7所示的内容修改main.m代码。
这段代码几乎都是Theos自动生成的，笔者将它重新封装了一下，可以用作XPC的基本框架。xpc_connection_create_mach_service()创建了一个服务，之后都是基于它进行通信的，
xpc_connection_set_event_handler()用于设置回调函数，
代码中最终的回调处理函数是pyg_iosre_book_app_peer_event_handler()，
当收到客户端发来的消息时，先取出action，然后根据其值进行各种功能处理。
实例里面处理了0x8899的功能逻辑：向客户端回复错误码和状态值，之后进入安全模式。

另外，实例中plist文件的内容和普通的守护进程不一样，多了一个MachServices参数。
其实该参数的作用与RunAtLoad一样，设置为“YES”就会在加载的同时启动。如下所示：

客户端的代码比较简单，
在start_xpc()里面仍然使用xpc_connection_create_mach_service()和服务端创建连接，只是最后一个参数传0，接着设置一个回调，
在btnClicked方法中调用xpc_connection_send_message()将字典数据发送过去。
关键代码如图8-8所示。

观察控制台日志可知，XPC进程通信符合预期效果：

XPC的目的是提高应用的安全性和稳定性，它让进程通信变得更容易，
但是细心的读者可能会发现，该方法仅限于系统级别的应用，如果用普通应用就是不可达的，这就引出了下面要讲的RocketBootstrap通信。
```

### 8.6.3 RocketBootstrap 通信

```
在私有框架AppSupport中存在一个CPDistributedMessagingCenter（分布式消息传送中心），它使用简单的消息和字典来提供不同进程之间的通信。

RocketBootstrap就是在其上进行封装，越过沙盒限制，给越狱环境提供稳定的进程通信服务。
在Cydia中搜索安装即可。

RocketBootstrap要求在权限比较高的进程中启动一个服务，再通过发送通知的方式越过沙盒限制，因此先创建一个tweak并注入SpringBoard进程，代码如下：

此处选择在“-(void)applicationDidFinishLaunching:(id)application”方法中注入代码，以确保SpringBoard加载时就能启动服务。

“-(void)handleMessage:(NSString*)name withUserInfo:(NSDictionary *)userInfo”方法用于处理各种逻辑。

本例处理了一个“AlertView”逻辑：当收到沙盒内发来的消息时，会弹出一个对话框，并显示出相应的参数。

在编译前需要配置一下Makefile，链接rocketbootstrap及加入AppSupport私有框架，如下：
  PYGIPHelper_LIBRARIES = rocketbootstrap
  PYGIPHelper_PRIVATE_FRAMEWORKD = AppSupport
  
通常情况下编译还是会报错：

这是因为找不到AppSupport框架。

Theos虽然包括了rocketbootstrap库，但是私有框架太大，也不是越狱开发必需的，所以用附属方式提供。
读者可以在https://github.com/theos/sdks找到很多SDK版本，这里选择和自己的SDK接近的版本就行了（比如笔者选择了iPhoneOS11.2.sdk），
同时网站还提供了一个create_patched_sdk.sh文件，用于自己从dyld_shared_cache中创建SDK。
```

```
下载的SDK文件有两种使用方法。
● 在iPhoneOS11.2.sdk/System/Library/PrivateFrameworks目录下找到所需的私有框架（当然也可以全部选择），复制到Applications/Xcode.app/Contents/Developer/Plat-forms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.0.sdk/System/Library/PrivateFr-ameworks目录下。
● 将整个iPhoneOS11.2.sdk文件夹复制到$THEOS/sdks/目录下。
  第一种方法需要修改Xcode目录，将来切换Xcode时，又需要复制一次文件；
  第二种方法只需要操作一次，但要修改Makefile的TARGET字段，强制指定SDK为下载的版本：
  TARGET = iphone:11.2:8.0
  
  至于实际使用哪种方法，读者自己斟酌。
  经过处理后，tweak就能编译通过了。
  在正式打包前，建议读者在control文件内添加依赖项：
  Depends:mobilesubtrate,com.rpetrich.rocketbootstrap(>=1.0.2) | fireware(<<7.0)
```

```
现在来编写客户端与tweak通信的代码。
用Xcode新建一个普通的应用，来求证RocketBootstrap是否具有越过沙盒的能力。
添加的关键代码如下：

接着还要配置一下头文件路径，
在“Build Settings”选项卡中搜索“Header SearchPaths”，添加“/opt/theos/vendor/include”，如图8-9所示。
接着将/opt/theos/vendor/lib/librocketbootstrap.tbd动态库引入，如图8-10所示。
编译运行后，单击“Test”按钮，成功弹出了对话框，说明沙盒越过成功，如图8-11所示。

本节讲述了三种进程通信技术，读者可以根据实际应用的复杂度合理选用。
随着iOS逆向技术的不断进步，将来一定会挖掘出更多的实用进程通信技术，
希望读者能到https://www.chinapyg.com交流心得。
```

8.7 MonkeyDev
-------------

```
Theos使用Makefile基于命令行方式编译生成deb文件，习惯使用Xcode的开发者可能不太适应这种方式，于是有了后来的iOSOpenDev。
它基于Xcode模板开发，在很长一段时间内都是越狱开发者的福音，但是该项目不再维护，因此在新的Xcode版本中不能很好地工作。
国内安全研究员在此基础上进行了修改，推出了一个全新的集成框架，名为“MonkeyDev”，它不仅能完美支持新版Xcode和新版Theos，还增加了一些非常实用的功能。
```

### 8.7.1 MonkeyDev 安装

```
在安装MonkeyDev之前，请确保Theos环境已经完全配置好，然后安装sshpass。
如下：
  brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb
 
 接着通过如下命令选择指定的Xcode进行安装：
   sudo xcode-select -s /Applications/Xcode9.app
 
 如果不指定，默认安装的Xcode如下：
   xcode-select -p
   
 执行下面的命令进行MonkeyDev安装：
   sudo /bin/sh -c "$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonKeyDevmaster/bin/md-install)"
  
  MonkeyDev同时提供了更新和卸载命令，进入/opt/MonkeyDev/bin目录，执行如下命令：
  # ~/opt/MonkeyDev/bin
  # 更新
  $ sudo ./md-update
  # 卸载
  $ sudo ./md-uninstall
  
  安装MonkeyDev不会影响Xcode的任何功能。
  安装之后，打开Xcode，单击“File”→“New”→“Project”菜单项，切换到“iOS”选项卡，在最下方即可看到MonkeyDev提供的模块（因为笔者曾经安装过iOSOpenDev，所以也会一起显示出来），如图8-12所示。
  根据需要选择模板，就可以创建对应的项目了。
```

### 8.7.2 Logos Tweak

```
选择Logos Tweak模板之后，会自动生成基础代码，由于Xcode无法识别*.xm文件，导致代码没有高亮效果，这时需要在Xcode界面右侧设置“Type”为“Objective-C++Source”，然后重新打开工程。完成后如图8-13所示。

其中，Logos.xm是工程的主文件，相当于Theos工程中的Tweak.xm，直接写Logos语法即可，在编译时会通过logos.pl转换成Logos.mm，
如果想了解具体的转换原理，可以查看这个文件；
Package相当于Theos的layout目录，会按照目录结构打包到最终的deb文件；

CydiaSubstrate.framework是基础依赖框架，项目会自动链接；
其他文件及作用都和Tweak中相同。

另外，在“Build Settings”列表下面的“User-Defined”会提供一些工程选项，如图8-14所示。

对这些选项的说明见表8-2。

其中，需要设置的项是MonkeyDevDeviceIP和MonkeyDevDevicePort。
通常使用的是USB连接，所以IP使用默认值即可。
笔者做了端口映射，因此端口填写了“2222”。
如果没有配置免密码登录或者配置失败，则将MonkeyDevDevicePassword设置为远程设备的密码（通常为“alpine”）。
写好代码，按〈Command+B〉快捷键，将会以Debug模式编译并安装到设备上，若要以Release模式编译安装，则按〈Command+Shift+I〉快捷键。
```

### 8.7.3 CaptainHook

```
TweakCaptainHook无须依赖Cydia Substrate框架，
它直接通过导入CaptainHook.h头文件后使用里面的宏来进行Hook。

CaptainHook的语法不易掌握，读者可以结合其帮助文档使用
（网址为https://github.com/rpetrich/CaptainHook/wiki）。
使用CaptainHook Tweak模板生成的工程结构如图8-15所示。

根据代码中的注释信息可知，可以按照以下步骤使用CaptainHook来Hook一个Objective-C方法。

1）使用CHDeclareClass()声明一个类。
2）使用CHLoadClass()或者CHLoadLateClass()在CHConstructor中加载声明的类。
3）使用CHOptimizedMethod()来Hook目标函数。
4）使用CHHook()在CHConstructor中注册Hook。
5）使用CHSuper()调用Hook原函数逻辑。

使用CaptainHook对iThunder的登录方法进行Hook，代码如下：

登录方法的参数多达5个，上面的代码看起来很乱，各种宏的使用也是让人晕头转向。这其实是利用了Objective-C的运行时特性进行的Hook，感兴趣的读者可以借助Xcode将这些宏展开进行观察（依次单击“Product”→“Perform Action”→“Preprocess xxx.mm”即可）。

CaptainHook虽然能脱离Cydia Substrate框架的依赖，但是其语法晦涩难懂，不易上手，笔者在实际工作中很少使用它，强烈推荐一个开源的ZKSwizzle库
（网址为https://github.com/alexzielenski/ZKSwizzle）。
ZKSwizzle的语法无限接近Theos，对它的学习没有任何障碍。上面的一大段代码改用ZKSwizzle实现仅需短短的几行：

需要注意的是，finishBlock的类型不能用id代替，否则会出现“ZKSwizzle:incompatible type encoding for….”错误，将其改为“void(^__nullable)(void)”即可。
```

### 8.7.4 Command-line Tool

```
使用Command-line Tool模板生成的工程结构如图8-16所示，主文件是main.c。monkeydev.entitlements文件添加了“platform-application”权限，以支持iOS11。

编译安装后，在iOS设备上输入对应的命令，执行如下：

/usr/bin root# CommandLine
PYGIOSRsBook
```

8.8 跟踪函数调用
----------

```
在逆向分析中，一定会碰到以下场景。
● 目标程序的类名及方法名被混淆，不能确定哪个方法被调用。
● class-dump后，文件太多，不容易确定哪个方法起主要作用。
● 利用运行时分析找到了控制器类，但类方法太多，不能快速确定哪个方法被调用。

除了在运行时利用Frida进行动态分析以外，还可以在tweak中添加一些简单而实用的代码来跟踪函数调用，从而解决这些复杂的问题。
在本节中，笔者将会分享一些实用的跟踪函数调用技术。
```

### 8.8.1 使用 logify 跟踪

```
利用Theos自带的logify工具对文件进行处理，它会逐个为函数添加日志信息并生成一个新的文件。
具体的使用方法如下：
logify.pl XLMemberManager.h > Tweak.xml
cat Tweak.xml

生成的文件通常需要做少许修改才能编译通过，安装tweak后，运行目标应用，即可通过控制台日志观察函数调用次序。
```

### 8.8.2 使用 ANYMethodLog 跟踪

```
ANYMethodLog的用途和logify相似，但可控度更高，它的代码托管在GitHub上，见https://github.com/qhd/ANYMethodLog。

学习ANYMethodLog基本无门槛，只需要了解一个类方法：
● aClass：要跟踪的类。
● condition：根据此block来决定是否跟踪方法（sel是方法名）。
● before：方法调用前会调用该block（target是检测的对象，sel是方法名，args是参数列表，deep是调用层级）。
● after：方法调用后会调用该block（interval是执行方法的耗时，retValue是返回值）。

下面以iThunder为例，讲解几种典型的用法。
```

```
（1）打印某个类定义的所有方法（公开和私有方法）

（2）打印运行过程中调用了哪些方法

（3）打印特定几个方法的调用顺序

（4）打印调用方法时的参数值

在实际使用时，需要在Makefile中加入ANYMethodLog.m才能正常编译，例如：

TWEAK_NAME = iThunderHelper
iThunderHelper_FILES = Tweak.xm ANYMethodLog.m #在这里加入
```

### 8.8.3 使用 BigBang 跟踪

```
相对ANYMethodLog来说，BigBang的功能比较专一，它主要用来Hook某个类的所有方法，打印所有方法的执行顺序。其代码可以在GitHub下载：https://github.com/codesourse/BigBang。使用BigBang仅需一句代码即可：
 [BigBang hookClass:@"XLMemeberManager"];
 
 别忘了在Makefile中加入BigBang.m：
 TWEAK_NAME = iThunderHelper
 iThunderHelper_FILES = Tweak.xm BigBang.m #在这里把BigBang.m加入
 需要特别注意的是，必须将它放到只会执行一次的函数里，以免被多次Hook。
```

8.9 增加系统设置项
-----------

```
在第5章曾讲到过一款FLEXible插件，它会在系统设置界面添加应用程序入口，单击进去可以进行一些详细设置、选择目标程序等。
这项功能极大地提高了插件的可控性，会使插件更加人性化。
本节将向读者讲解这些技术的实现。
```

### 8.9.1 PreferenceLoader

```
PreferenceLoader是一个开源的基础依赖包（网址为https://github.com/DHowett/preferen-celoader），
越狱插件的系统设置菜单就是由它提供的，所以在开发之前务必先在越狱商店中搜索“PreferenceLoader”并安装。

进入系统设置时，PreferenceLoader会从/Library/PreferenceLoader/Preferences/目录（包含子目录）下解析符合规则的plist文件，
并生成相应的控件动态添加到系统设置中。
```

```
1.基本用法首先演示的是类似于“飞行模式”的开关效果，这是最简单的配置方式，仅有一个总开关。
（1）plist文件构造一个基础的plist文件内容如下：

● entry：整个配置文件的入口，它是一个字典类型。

● cell：表示一个单元格，这里是PSSwitchCell，表示一个开关控件。
更多的控件请读者参考http://iphonedevwiki.net/index.php/Preferences_specifier_plist。

● defaults：关联的用户默认值。实际上就是存放于/var/mobile/Library/Preferences/目录下的一个plist文件，文件名就是defaults指定的（此处为/var/mobile/Library/Preferences/com.chinapyg.TestSettings.plist）。

● label：表示该cell显示的文字信息。

● key：在defaults中用于关联该cell的键值。

● default：表示该cell的默认值，这里表示默认为“打开”状态。

● icon：表示该cell前面显示的图标。

将上述内容保存到test1.plist文件，
然后进入iOS设备的/Library/PreferenceLoader/Preferences/目录，
并建立一个PYG子目录，
将test1.plist、PYG.icon文件上传至此，完成后如下：

/Library/PreferenceLoader/Preferences/PYG root # ls -al

打开系统设置，即可看到图8-17所示的效果。

（2）交互逻辑目前添加的系统设置菜单仅是一个UI展示而已，没什么实际意义，需要添加具体的交互逻辑才能让它变“活”。
    用8.2节的iThunderHelper示例进行改造，增加交互逻辑，如图8-18所示。

   上述内容增加了一个shouldHookFromPreference函数来读取指定的key值，从而判断是否需要进行Hook，经过测试运行正常。
```

```
2.常规用法
  对于需要设置多个参数的插件来说，基本用法显然是不能满足要求的，通常都需要提供子页面用于详细设置，这时仅需对plist做少量改动即可实现。
  修改后的plist内容如下：
  可以看到入口的cell改为了PSLinkCell类型，这样单击后就会进入子页面，子页面的内容由items数组控制，可以添加多个。
  上一步的开关控制代码被移动到这个子页面内，同时在底部添加了一个PSGroupCell分组，footerText表示底部显示的信息。
  将该内容保存为test2.plist上传到设备，再次打开系统设置，效果如图8-19所示。

由于PSSwitchCell的defaults及key值没有改变，所以tweak的代码不需要做任何改动即可适配。

除了上述几种使用方法之外，还可以配合PreferenceBundles构建自己的扩展来进行个性化定制，这些扩展包位于/Library/PreferenceBundles/目录内。
由于篇幅有限，请读者查阅http://iphonedevwiki.net/index.php/PreferenceBundles进行学习。
```

### 8.9.2 AppList

```
AppList用来获取应用程序的信息，允许开发人员查询已安装的应用程序列表，并获取各种配置信息，是PreferenceLoader的“黄金搭档”，直接从越狱商店搜索并安装即可
```

```
1.plist文件构造AppList常用的键及其说明见表8-3。表8-3 AppList常用的键及其说明

笔者根据这些信息及官方文档构造了一个plist通用模板，如下：

该模板在ALSectionDescriptors中分别列出了
  用户级应用列表（isSystemApplication=FALSE）和
  系统级应用列表（isSystemApplication=TRUE），基本能应对各种插件的需求。
 在使用时仅需要修改ALSettingsPath，指向自己的配置文件即可（注意路径不要改变）。
 将上述文件保存为test3.plist并上传到设备，再次打开系统设置，可以看到AppList已经生效了，如图8-20所示。
 
 此时打开/var/mobile/Library/Preferences/com.chinapyg.applist.plist配置文件，可以查看到配置详情，如图8-21所示。
 
 至此，构造配置文件的工作就完成了。
```

```
2.交互逻辑与PreferenceLoader一样，要使编写的插件受控于AppList，还应编写一小段代码进行交互。

只要判断目标应用的BundleID是否在配置文件内启用就能决定是否需要注入，关键代码如下：

通过日志可以确定已经交互成功，如图8-22所示。

读者可以结合8.5.2节所讲的自动部署技术，将配置文件集成进工程中，完成一键打包。
```

8.10 deb 重打包
------------

```
通过前面的学习，大家知道iOS插件在编译打包后，最终会以deb包的形式呈现。
deb里面可以包含一系列命令或特殊功能所必需的依赖文件，出于某些特殊原因，有时需要直接对别人的deb包进行修改，例如修改图片、破解使用限制等，这就要用到deb重打包技术。
本节选用一个名为“apt.tinyapps.XGPSPro_3.7.6_iphoneos-arm.deb”的文件来讲解deb重打包技术。
```

```
1.准备工作
要修改包内文件，肯定需要先解包，在这之前，先做一些准备工作：
新建根目录（笔者将它命名为“deb_repackage”），将目标文件复制进来。具体如下：
~/path/to/deb_repackage
```

```
2.新建必要的目录
  这一步新建extract、extract/DEBIAN和build目录，用来存放解包后的文件及打包后的文件。命令如下：
  mkdir extract
  mkdir extract/DEBIAN
  mkdir build
```

```
3.开始解包解包和打包都需要用到dpkg命令，如果提示“command not found:dpkg”错误，请使用下面的命令安装dpkg：
  brew install dpkg
  
  -X参数可以提取deb包中的所有文件到extract目录，
  -e参数可以提取deb包中的控制信息到extract/DEBIAN目录，操作如下：
  
  dpkg -X ./apt.tinyapps/XGPSPro_3.7.6_iphoneos-arm.deb extract
  dpkg -e ./apt.tinyapps/XGPSPro_3.7.6_iphones-arm extract/DEBIAN
  
  此时，解包就算完成了，文件结构如图8-23所示。
  
  这时就可以进行各种修改了，细心的读者应该会发现extract其实就等于开发时的layout文件夹。
```

```
4.重新打包
  deb包修改完成后，下一个环节就是重新打包，在这之前先检查目录下是否存在.DS_Store文件，有的话，用下面的命令批量删除：
  find ./ -name ".DS_Store" -depth -exec rm {} \;
  
  然后先设置用户组权限再打包，即可在build目录生成新的deb包，具体如下：
  sudo chown -R root:wheel ./extract
  Password
  dpkg-deb -b extract /build/
  dpkg-deb:building package 'apt.tinyapps.xgpspro' in 'build//apt.tinyapps.xgpspro_3.7.6_iponeos-arm.deb'.
  
如果安装时发生“dpkg-deb (subprocess): unable to execute decompressingarchive member (xz):No such file or directory”错误，将打包命令修改成如下语句即可：
   dpkg-deb -Z gzip -b extract/ build/
```

8.11 本章小结
---------

```
本章详细讲解了使用
  Theos进行插件开发、
  命令行工具开发、
  系统级应用开发及
  守护进程开发的过程，
  另外还讲解了多种进程通信技术及时下比较流行的MonkeyDev框架的基本使用方法，
  与此同时，笔者也将日常工作中的一些高级技巧分享出来供读者学习。总之，认真学完本章就能独立开发各种功能强大的插件了。
```

第 9 章 Hook 与注入
==============

```
Hook与注入技术是相辅相成的，在逆向工程领域占据着举足轻重的地位，涉及的领域非常广泛，如病毒木马领域、杀毒安全领域、游戏安全领域等，因为它可以改变程序的执行流程，执行自己编写的代码等。
```

9.1 Method Swizzling
--------------------

```
Method Swizzling是改变一个selector的实际实现技术。
通过这一技术，可以在运行时通过修改类分发表中selector对应的函数，来达到Hook的目的。
```

### 9.1.1 Method Swizzling 原理

```
在Objective-C中调用一个方法，实则是向一个对象发送消息，查找消息的唯一依据是selector的名字。
每个类都有一个方法列表，存放着selector和IMP的映射关系。
IMP有点类似函数指针，指向具体的Method实现，如图9-1所示。

利用Objective-C的动态特性，可以实现在运行时调换selector对应的方法，达到Hook的目的，这正是Method Swizzling的原理，如图9-2所示。
```

### 9.1.2 Method Swizzling 实例

```
Method Swizzling能做的事情非常多，比如要在每个ViewController加载的时候都插入一个跟踪日志信息，

常规的做法是逐个修改ViewController的viewDidLoad方法来添加跟踪日志，在工程不复杂的情况下这样做是没什么问题的，
如果工程复杂，涉及的ViewController非常多，那修改起来就变得非常麻烦了。
这种情况下，使用Method Swizzling在非常小的改动下就能完成需要的功能。
```

```
用Xcode新建一个基于Single View App模板的工程，给UIViewController增加一个分类，然后在+load方法里面交换viewDidLoad的IMP：

在Objective-C中，运行时会自动调用+load方法，因此这里是编写初始化代码最优雅的位置。

在+load方法中使用自己封装的swizzWithClass方法来进行MethodSwizzling，

所以viewDidLoad方法在一开始就会被替换成swizz_viewDidLoad方法。

这样一来，整个逻辑就被swizz_viewDidLoad方法控制了，可以在这里做一些想做的事情，比如打印一些跟踪日志信息等，最后调用的[selfswizz_viewDidLoad]才是原始的viewDidLoad方法（因为已经交换了IMP），这样就轻而易举地在原始方法前面插入了需要的代码。

现在仅需要在ViewController.m中添加一行“#import"UIViewController+Swizzle.h"”就达到日志追踪的目的了，运行一下程序可以看到swizz_viewDidLoad先执行，然后调用-[ViewController viewDidLoad]，说明Method Swizzling是成功的：

call -[UIViewController(Swizzle) swizz_viewDisLoad]
call -[ViewController viewDidLoad]

上面为什么要使用dispatch_once呢？
这是因为Swizzling会改变全局状态，所以在运行时需要采取一些保护措施。
GCD（Grand Central Dispatch）的dispatch_once可以确保不管有多少个线程，代码都只被执行一次。

在实际应用中，强烈建议使用ZKSwizzle库，仅需要少数代码就能实现同样的功能：
hook(UIViewController)
-(void) viewDidload{
  NSLog(@"call %s", __FUNCTION__);
  ZKOrig(void);
}
```

### 9.1.3 MSHookMessageEx 实例

```
Cydia Substrate框架中提供了MSHookMessageEx函数，
利用运行时机制对Objective-C方法进行替换，函数原型如下：
  void MSHookMessageEx(Class _class, SEL message,IMP hook,IMP *old);
  
● _class：表示要Hook的Objective-C方法的类名。
● message：表示要Hook的Objective-C方法。
● hook：表示替换后的方法实现地址。
● old：为原方法的地址，若无须调用原方法，则该参数可以设为NULL。实例代码如下：

实际使用中通常不会直接使用MSHookMessageEx函数，
Theos的Logos语法已经对MSHookMessageEx进行了封装，使用起来更加方便：

在未越狱机器上想要用MSHookMessageEx函数就不那么方便了，需要将其依赖库libsubstrate.dylib也一起打包进去才能正常使用，为了用一个封装好的函数而增加一个动态库，在笔者看来还是略显多余的。
如果想让自己编写的动态库同时支持未越狱的设备，还是使用ZKSwizzle比较好。
```

### 9.1.4 获取类成员变量实例在编写插件的过程中，有时候需要获取类成员变量，可以采用以下几种方式：

```
● 使用原生的valueForKey:方法。
● 使用substrate.h提供的MSHookIvar方法。
● 使用ZKSwizzle提供的ZKHookIvar方法。
仍然以iThunder登录方法为例，分别用以上三种方式获取成员变量的值，代码如下：
```

9.2 Inline Hook
---------------

```
因为C/C++并没有运行时机制提供的这些高级API来直接替换方法实现，所以Method Swizzling对它是无效的，需要使用Inline Hook才能达到目的。
iOS上的Inline Hook和Windows平台上的原理几乎一模一样，都是修改函数的前N字节内存，使其跳转到自己编写的函数，这样原函数的逻辑就被新的函数接管了，同时还应该保存原函数的前N个字节，以便在需要时能正确恢复原来的汇编代码从而执行原始逻辑。
```

### 9.2.1 MSHookFunction 实例

```
Cydia Substrate框架中提供了MSHookFunction函数来完成Inline Hook，其原型如下：
  void MSHoolFunction(void *Symbol, void *hook, void **lod);
  
● symbol：表示需要Hook的地址，该地址并不局限于函数头，也可以是函数内部的任意地址。
● hook：表示替换后的函数地址。
● old：保存被Hook函数的原始代码，若不需要调用原函数，此处可以直接设为NULL。
```

```
以getenv函数为例进行Inline Hook，代码如下：
  static char* (*pfn_getenv)(char* key);
  static char* my_getenv(char* key){
    return pfn_getenv(key);
  }
  %ctor{
    MSHookFunction((void*)getenv,(void*)&my_getenv,(void**) &gfn_getenv);
  }
  }
```

### 9.2.2 fishhook 实例

```
在学习Mach-O文件格式时，提到过“懒绑定”和“非懒绑定”的概念，由Facebook开源的fishhook框架正是通过修改“懒绑定”和“非懒绑定”两个表的指针来达到C函数Hook的目的。

对于程序引用的动态库中的C函数，

第一次调用的时候会得到函数和具体实现地址的对应关系，
函数的实现地址存放在一个叫__la_symbol_ptr的地方（类似于PE文件的IAT表），
而对于动态库的全局数据，则是放在__nl_symbol_ptr中；

第二次调用的时候，直接通过__la_symbol_ptr找到函数地址就可以，不再需要烦琐的获取函数地址的过程。fishhook的核心工作就是替换__la_symbol_ptr及__nl_symbol_ptr中的数据。

fishhook的主要接口仅有一个：
仍然以getenv函数为例，代码如下：
```

### 9.2.3 HookZz 实例

```
HookZz是由jmpews开发的一套Hook框架，它支持iOS、Android平台下的ARM、ARM64架构。
其代码托管在GitHub（https://github.com/jmpews/HookZz）上，下载后编译成静态库或动态库即可。笔者习惯将它们统一放到/opt/theos/vendor/目录下，利用Theos的tweak模板进行编译、安装（只要稍微配置就不会再依赖CydiaSubstrate）。

仍然以getenv函数为例，代码如下：
修改makefile文件，链接HookZz静态库及去掉CydiaSubstrate依赖：
 
HookZz还有很多高级技巧，读者请查看官方帮助文档学习。
此外，HookZzModules是笔者基于HookZz编写的一些实用模块，可以直接使用。
```

9.3 Swift Hook
--------------

```
Swift是苹果公司新推出的一门开发语言，新项目很多都使用它来开发。
Swift的难度要大于Objective-C，但也不是没有规律可循，本节探讨Swift程序的逆向分析与Hook。
```

### 9.3.1 Swift 逆向分析

```
先用Xcode建立一个基于Single View App模板的工程，语言选择Swift，并修改生成的代码：
 
用Hopper打开生成的二进制文件，通过关键字找到viewDidLoad方法的反汇编代码：

由此可以清晰地看到viewDidLoad实际上是一个包装，内部调用的SwiftApp.ViewController.viewDidLoad()才是真正的实现，查看到伪代码如下：

这个名为“_TtC8SwiftApp14ViewController”的类似曾相识，这是Swift独有的编码规则，主要为了解决程序实体名字必须唯一的问题。
它将函数名称、参数类型、返回类型等参数编码到名字中，形成一个唯一标识。使用nm命令可以读取整个符号表，如下所示：

这种编码后的标识虽然用肉眼基本可以识别，但是有点烦琐，
Xcode附带了一个名为“Swift-demangle”的工具，专门用来解析这些标识。读者可以通过-help参数查看详细使用方法。以解析_TtC8SwiftApp14ViewController为例，常规使用方法如下：

Swift程序的逆向分析资料目前还积累宝贵的经验。
```

### 9.3.2 Swift Hook 实例

```
对于Swift程序的外层函数仍然可以使用Logos语法进行Hook，只是类名需要改成Siwft编码后的，反之可以使用MSHookFunction()与C函数一样进行Inline Hook。

本节对9.3.1节示例的外层viewDidLoad以及calc函数分别进行Hook。使用Theos新建一个SwiftAppHook的tweak工程，添加代码如下：

编译并安装后，运行目标程序看到控制台按照预期输出了日志，如图9-3所示。
```

9.4 注入技术
--------

```
为了对内存中的某个进程进行操作，并
获取目标进程地址空间内的信息，
或者修改目标进程的内存数据，就需要用到注入技术。
通过注入技术可以将模块加载到目标进程中，在注入成功后便可以访问和更改目标进程空间内的信息（如数据、代码等）。
```

### 9.4.1 越狱环境注入

```
由Cydia Substrate框架提供的MobileLoader是iOS越狱环境下实现注入的核心功能模块。

系统启动时会先执行“/private/etc/rc.d/substrate”脚本，
调用cynject将SubstrateLauncher.dylib注入PID为1（launchd）的进程中，脚本内容如下：
 !/bin/bash
 exec /usr/bin/cynject1/Library/Frameworks/CydiaSubstrate.framwework/
 
 Library /SubstracteLauncher.jylib

由于launchd进程跟随系统最先启动，之后所有启动的应用都是它的子进程，
而SubstrateLauncher.dylib里面Hook了launchd进程的posix_spawn函数（posix_spawn函数用来创建一个新进程，每个新进程启动都会执行），这样就顺理成章地接管了所有应用的启动过程。

与此同时，MobileLoader由launchd进程加载到内存，
然后MobileLoader会利用DYLD_INSERT_LIBRARIES环境变量将自身加载到iOS设备的各个进程中，
并遍历Library/MobileSubstrate/DynamicLibraries/目录下的plist配置文件，如果符合规则，会将与plist同名的dylib文件使用dlopen()函数动态加载到目标进程。

知道了上述原理，通过任何方式（不一定需要Theos）编写dylib和plist配置文件，都可以让MobileLoader组件将其注入指定的应用中。

当然，读者也可以参考“/private/etc/rc.d/substrate”脚本的方式，使用cynject强行注入某进程。该方法不需要特定的plist文件，cynject的使用方法是：
  /usr/bin/cynject <pid> <dylib>
```

### 9.4.2 非越狱环境注入

```
随着iOS版本的不断更新，顺利越狱已经变得越来越困难，因此非越狱环境的注入变成了一个热门话题，近年来引起了许多逆向研究人员的极大关注。

在第3章学习Mach-O文件格式时，曾介绍过LC_LOAD_DYLIB加载命令，里面存放了应用正常运行所需要的各种依赖库，而只要想办法插入一条新的LC_LOAD_DYLIB加载命令，并将路径指向自己的动态库，就能实现非越狱平台的注入了。

新添加的LC_LOAD_DYLIB通常位于最后一条，且路径一般以@rpath、@executable_path开头。

使用MachOView打开被注入过的目标文件可以验证这一点，如图9-4所示。

读者可能留意到，市面上有很多类似于“XX多开”“XX游戏修改版”的应用，就是利用非越狱环境注入dylib实现了对原始包的篡改，再重签名后即可达到目的。

从安全的角度考虑，对于这类非官方应用需要谨慎使用，以防被别有用心的人植入恶意代码。

下一节将从学习、研究的角度来讲解非越狱环境注入dylib的具体实施过程。
```

### 9.4.3 注入 dylib 实例

```
1.准备dylib
先用Theos编译一个名为“test.dylib”的动态库用作注入，代码如下：

特别注意，直接编译生成的test.dylib会依赖CydiaSubstrate框架，如图9-5所示。

这对于非越狱系统来说，不但没有意义，还会因为找不到依赖库而导致崩溃，所以对makefile进行如下配置将这个依赖去掉：

再次编译后的test.dylib文件已经没有了CydiaSubstrate依赖，如图9-6所示。
```

```
2.注入dylib将目标应用AVPlayer解包，把生成的test.dylib文件复制到解包后的Payload/AVPlayer.app目录下。
下面分别讲述yololib和optool的操作方法。

（1）yololib
从https://github.com/KJCracks/yololib下载源代码，用Xcode打开工程文件，编译得到yololib可执行文件。
yololib的使用极其简单，无需过多的参数设置。使用如下命令：]

$ ./yololib ./Payload/AVPlayer.app/AVPlayer test.dylib

如果提示“complete!”则说明添加成功了，可以用MachOView确认一下，如图9-7所示。
```

```
（2）optool
 optool的功能比yololib强大很多，不但能添加动态库，还能将已存在的动态库删除。
 使用如下命令从GitHub下载源代码再初始化子模块：
 git cline https://github.com/alexzielenski/optool.git
 cd optool
 git submodule update --init --recursive

接着用Xcode打开optool.xcodeproj工程文件，直接编译得到optool可执行文件
（笔者将其复制到了/usr/bin目录）。使用方法如下：

#添加dylib依赖
optool install -c load -p "@executable_path/test.dylib" -t ./Payload/AVPlayer.app/AVPlayer

#删除dylib依赖
optool uninstall -p "@executable_path/test.dylib" -t ./Payload/AVPlayer.app/AVPlayer

注入过程就告一段落，当然这样处理后是不能正常安装的，还需要重签名的环节，下一节将会详细讲解。
```

9.5 应用重签名
---------

```
一旦修改了应用的二进制文件，或者增加、修改了应用里面的资源，应用本身的签名就会被破坏。
由于iOS内核中强制部署了许多代码签名机制，运行修改后的应用会闪退甚至安装不成功，这样就可以避免攻击者在用户的设备上传播并运行不受信的代码。

如果想让应用顺利运行，就需要对其进行重签名，本节将对修改后的AVPlayer示例进行多种重签名方式的详解。
```

### 9.5.1 手动重签名

```
1.生成Provisioning Profile这一步是为目标设备生成匹配的Provisioning Profile。
先创建一个空白Xcode项目，将“Deployment Target”设置为与目标设备匹配的版本，然后设置好BundleID，如图9-8所示。
在编译项目后，如果不小心已经部署到设备上，请务必先在设备上将其删除，否则重签名后的应用将安装不成功。
 
下一步就是从空项目中提取Provisioning Profile，用在待打包的应用上。
先在“Products”→“resign_app.app”节点上右击，选择“Show in Finder”命令，定位到编译后的应用目录，如图9-9所示。

将resign_app.app包内的embedded.mobileprovision文件复制到解包后的Payload/AVPlayer.app/目录下。
```

```
2.提取entitlement
使用如下命令从生成的Provisioning Profile中提取entitlement：
  $ security cms -D -i embeded.mobileprovision > profile.plist
  $ /usr/libexec/PlistBuddy -x -c 'Print:Entitlements' prifile.plist > entitlements.plist

提取完成后将entitlements.plist放到Payload的同级目录，此时的目录结构应该是下面这样的：
```

```
3.更新BundleID接下来需要将AVPlayer应用的BundleID更新为之前生成的Provisioning Profile的BundleID。
在本例中，Provisioning Profile中的BundleID为“com.chinapyg.resign-app”。
可以手动修改或者使用如下命令更新Payload/AVPlayer.app目录中的Info.plist文件：
  $ /usr/libexec/PlistBuddy -c "Set:CFBundleIdentifier com.chinapyg.resign-app" Payload/AVPlayer.app/Info.plist
```

```
4.获取证书列表
通过如下命令获取本机证书列表，然后选择一个用于签名的证书。
 security find-identity -p codesigning -v
接下来将选用第一个证书进行签名。
```

```
5.签名
签名的目标包括文件夹中的所有动态库、插件、扩展。
下面的命令演示如何对动态库进行签名：
codesign --force --sign "iPhone Developer:piaoyunsofy@icloud.com(SJ3MLG9AQ6)" Payload/AVPlayer.app/test.dylib

最后对整个AVPlayer.app文件夹进行签名，命令如下：
codesign --force --sign "iPhone Developer:piaoyunsofy@icloud.com(SJ3MLG9AQ6)" --entitlements entitlements.plist Payload/AVPlayer.app

如果出现提示“resource fork, Finder information, or similar detritus notallowed”，则需要先执行如下代码再重新签名：

xattr -rc
```

```
6.打包
应用重新签名后，可以使用zip命令将Payload目录重新打包为ipa文件：
zip -qr AVPlayerNew.ipa ./Payload
```

```
7.测试用PP助手或者Xcode将重签名后的ipa文件安装到设备，启动AVPlayer应用，控制台顺利输出日志，说明test.dylib加载成功了，如图9-10所示。

如果安装失败或者运行闪退，请仔细检查每一步。
```

### 9.5.2 使用 iOSAppSigner 重签名

```
iOSAppSigner是一个可视化的签名工具，它免除了在终端输入命令的烦琐步骤。
iOSAppSigner采用Swift语言编写，源代码托管在GitHub上：https://github.com/DanTheMan827/ios-app-signer，下载后用Xcode打开编译生成可执行文件。

通常情况下使用iOSAppSigner签名只需要进行三步设置。
● 选择待重签名文件（ipa包或者.app目录），支持拖动操作。
● 选择重签名证书（请确保证书已被添加）。
● 选择重签名描述文件。

然后单击“Start”按钮，选择保存路径，就可以生成一个重签名后的ipa包，非常简单。
操作过程如图9-11所示。
```

### 9.5.3 使用 fastlane 重签名

```
fastlane是一套非常实用而强大的组件，旨在将iOS和Android的发布流程自动化，提高效率。
它是一套Ruby脚本的集合，里面的每一个工具实际就是一个Ruby脚本。
它可以简化一些乏味、单调、重复的工作，如截图、证书维护、代码签名以及发布应用。
本节仅使用它的代码签名工具。

1.安装fastlane
fastlane基于Ruby编写，macOS系统已经自带了Ruby，所以安装极为简单，用如下命令即可：
 sudo gem install fastlane
耐心等待一会儿，fastlane就安装完成了。

2.使用fastlane
在合适的位置新建一个文件夹，将待签名的ipa包以及描述文件放进去，目录解构如下：

在刚刚创建的文件夹内打开终端，执行“fastlane sigh resign”命令，稍后就会列出所有证书。
选择描述文件对应的证书，复制到指定位置，如果没有问题，最后会提示签名成功，如下所示：
  fastlane sigh resign

需要注意的是，如果被签名的程序注入了dylib，
需要先用前面手动签名的方法，使用codesign将dylib签名，
再用fastlane重签整个ipa包，否则会安装失败。
```

### 9.5.4 使用 MonkeyDev 重签名

```
MonkeyDev提供了MonkeyApp类型的模板，可以借助它来签名。
新建一个MonkeyAppDemo工程，然后在工程目录下的TargetApp文件夹里面放入需要签名的ipa包或者解压后的文件夹，运行就能直接将签名好的ipa安装到设备了，如图9-12所示。

在MonkeyApp工程里面还能直接修改dylib的代码，不需要做任何配置就会被自动注入主程序，用于非越狱插件集成时非常方便。

本节介绍的四种方法，读者可以根据实际情况选用，笔者更加倾向于使用fastlane工具，因为它的灵活性更高。
```

9.6 本章小结
--------

```
本章先对Hook技术进行了原理上的讲解，并实例演示了不同类型的Hook方法，
然后对越狱和非越狱环境下的注入技术进行了讲解，并实例演示了具体的实施过程，最后介绍了为应用重签名的多种方法。
```

第 10 章 应用安全
===========

```
学习了前面的章节后，读者可以轻而易举地逆向分析一些感兴趣的应用，而本章恰好相反，更多的是关注软件安全开发技术，试图阻止各种逆向分析。
对于正向开发人员而言，关注应用安全，保护自己开发的应用不被轻易逆向或破解是非常必要的。
本章除了涉及目前已经公开的一些技术外，还有笔者从日常逆向工作中所总结的一些技术。
```

10.1 调试器对抗
----------

```
调试器在软件工程领域是不可缺少的利器。
逆向工程利用调试技术可以窥探应用运行的“秘密”，因此开发人员会想尽一切办法对自己的应用建立“马其诺防线”，让逆向人员无法动态调试。
正因为如此，调试器之间的对抗变得越来越激烈，各种反调试、反-反调试技术也层出不穷。
```

### 10.1.1 反调试

```
对于逆向研究人员来说，经常会见到一些反调试（Anti）技术。
开发人员通过反调试手段防止核心代码被动态跟踪，恶意代码则需要隐藏自己的行为防止被逆向。
反调试主要分为反附加和检测调试器两类，下面介绍一些常见的反调试方法。
```

```
1.ptraceptrace函数源于UNIX的早期版本，是一种对运行中的进程进行跟踪和控制的手段。
  通过ptrace，一个进程可以动态地读写另一个进程的内存和寄存器，包括指令空间、数据空间、堆栈以及所有的寄存器。
  同时，ptrace还提供了一个非常有用的PT_DENY_ATTACH参数，用来告诉系统阻止调试器附加。
  所以，最常用的反调试就是通过调用ptrace来实现，示例如下：
```

```
2.sysctl当目标进程被调试的时候，会有一个标志位表明自己正在被调试，
  所以可以通过sysctl去查看当前进程的信息，从这个标志位得到当前的调试状态。
  示例如下：
  检测到调试器后可以造成崩溃、暗桩或直接退出等。
  示例代码里面直接调用了exit(0)来强制退出程序。
```

```
3.syscall为了实现从用户态切换到内核态，系统提供了一个syscall函数，上面提到的ptrace也是通过系统调用去实现的。
  在sys/syscall.h中可以找到ptrace对应的编号：
  所以如下的代码就等同于调用ptrace：
```

```
4.svc若不想暴露自己的ptrace等系统方法，不想被符号断点中断，
  可以采用syscall的汇编代码形式来调用ptrace，以实现从用户态到内核态的切换。示例如下：
  
  w16的参考值可以在sys/syscall.h中找到，共有500多个定义。
  一定要记得添加“__attribute((always_inline))__”属性，让编译器将此函数强制内联，以免被轻易Patch（指补丁修补）掉。
  IDA会将此段代码识别为mac_syscall，如图10-1所示。
```

```
5.isatty
  isatty()函数检测文件描述符是否连接到一个终端设备，如果是则返回1，
  而LLDB调试时需要远程连接iOS设备，因此可以利用它来做反调试。
  另外还有一些检测手段，经过笔者测试对新版系统不适用，故没有列出。
```

### 10.1.2 反 - 反调试

```
既然是对抗，那么有反调试就一定会有反-反调试。
本节主要针对ptrace、sysctl、syscall进行反-反调试。
代码如图10-2所示。
对于SVC汇编层的反调试绕过方法，请使用HookZzModules来解决，具体请参考官方示例：https://github.com/jmpews/HookZzModules/tree/master/AntiDebugBypass。
```

10.2 注入对抗
---------

```
在越狱环境下，某个插件要起作用就必须注入目标程序。
注入的方式通常是使用DYLD_INSERT_LIBRARIES环境变量将dylib载入，而开发者会通过各种手段来对注入行为进行拦截或者是检测，最大限度保证自身程序的安全性。
本节讲述常规反注入和注入检测的方法。
```

### 10.2.1 反注入

```
当自己编写的dylib无法加载到目标应用的时候，就表明此应用做了反注入保护。
在iOS 10以下的系统中，当dyld检测到Mach-O中存在“__RESTRICT,__restrict”这样的节（Section）时，DYLD_INSERT_LIBRARIES环境变量会被忽略，导致注入失败。
因此，在Xcode的编译设置选项“Other Linker Flags”中加上“-Wl,-sectcreate,__RESTRICT,__restrict,/dev/null”参数，
如图10-3所示。

此时用MachOView查看生成后的可执行文件，会发现添加了一个“__RESTRICT,__restrict”，如图10-4所示。

这时用Theos编写一个tweak发现无法正常注入了。
为什么增加这样的一个Section就能阻止dylib注入呢？
查看https://opensource.apple.com/source/dyld/dyld-210.2.3/src/dyld. cpp.auto.html中的pruneEnvironmentVariables函数即可知道答案，如图10-5所示。

需要注意的是，该方法在iOS 10及以上系统无效。
当然反-反注入的方法也是有的。
● 第一种方法是把section的名字修改一下（如果主程序同时具备完整性检测，那就不行了）。
● 第二种方法是使用Cydia自带的cynject工具进行注入，这种方式无惧主程序的完整性检测，具体方法为/usr/bin/cynject<pid><dylib>
（其中，pid代表被注入的进程ID，dylib表示被注入的动态库）。
```

### 10.2.2 注入检测

```
1.检测加载模块
注入检测的方式多种多样，
其中最常用的是判断加载模块中是否存在一些已知的敏感路径（比如DynamicLibraries）。
使用_dyld_get_image_name获取模块名，然后进行匹配，示例如下：
另外，还应该逐个检测Mach-O的LoadCommand，以防被类似yololib的工具注入dylib。
```

```
2.检测环境变量
注入环境虽说不一定依赖CydiaSubstrate，但其原理都是通过DYLD_INSERT_LIBRARIES注入dylib，因此可以通过检测环境变量来确定是否被注入。
方法1：
方法2：
如果返回结果是NO，表明没有被注入。
```

```
3.实时监控dylib
  使用_dyld_register_func_for_add_image注册回调后，
  在任意时刻只要dylib被加载，都会进入此回调，利用这个特性可以实时监控dylib的加载。
  回调函数代码如下：
  注册回调的位置也是有讲究的，可以写在构造函数里面：
  对于OC类，可以写在+(void)load方法里面：
  即使使用cynject工具进行注入，也会触发回调函数，只要把回调函数逻辑写得非常完整，第三方的dylib基本是“插翅难逃”，因此笔者更加推荐此法。
```

### 10.2.3 注入防护

```
提供支付功能的应用如果被非法注入，后果将不堪设想，前面几节讲的方法都是从自身进行防护，这些方式终归有局限性。
既然是在权限相当高的越狱环境下，完全可以从系统层面入手做一款防护插件，来为指定的应用保驾护航。
大家知道，在安全模式下，所有基于Cydia Substrate的第三方dylib将被禁用，
笔者有个大胆的想法：如果事先将自己编写的插件注入某个高权限的系统应用，然后监控目标应用的启动，再人为制造一种进入安全模式的“假象”，不就能实现dylib注入防护了吗？
```

```
1.逆向分析
带着这些疑问，先对SubstrateLoader.dylib进行逆向分析，查看进入安全模式的实现，发现仅需设置一个_MSSafeMode环境变量即可，如图10-6所示。
因为要进行全局监控，所以选择注入SpringBoard中，
现在的问题是，从哪里插入代码才是最佳时机？查阅资料可知，SpringBoard中与应用启动有关的类为SBApplication。
静态分析SpringBoard主程序，找到一个内部方法“-[SBApplication_appInfo]”，从名字来看它保存了应用的具体信息，如图10-7所示。
这里面取了一个FBApplicationInfo类型的成员变量，使用frida-trace对其追踪：
分析调用日志，笔者一眼看到了“-[FBApplicationInfo environmentVariables]”方法，这么明显的命名，到底返回什么内容呢？
修改脚本打印返回值如下：
果然，这个方法返回了应用所需的各种环境变量，在这个方法内追加_MSSafeMode环境变量即可。
```

```
2.代码实现
将8.9.2节的示例复制一份稍作修改后用于本节的演示，工程名改为“aaaaaaDisable Tweak”，
确保优先加载（因为tweak会按照字母顺序决定优先级），
然后将plist文件的Filter设置为com.apple.springboard，最后修改Tweak.xm代码如下：
此时再打开目标应用测试，会发现所有的dylib都不能注入了，防护成功。
```

10.3 Hook 检测
------------

```
iOS上的Hook方式无外乎就两种：Method Swizzing及Inline Hook，本节分别讲解其检测方法。
```

### 10.3.1 Method Swizzing 检测

```
Method Swizzing的原理是替换IMP，所以可以通过dladdr得到IMP地址所在的模块信息进行判断，简单的示例如下：
```

### 10.3.2 Inline Hook 检测

```
Inline Hook的原理是通过修改函数的前N字节内存，使程序跳转到自己编写的函数。
有过Windows逆向经验的读者应该对Inline Hook的检测不会陌生，
即检测函数头部若干字节是不是被修改，在iOS上此手段依旧有效。
为了研究检测机制，先查看一下被其Hook前后的getenv函数的反汇编代码：
● Hook前：
  disassemble -b -n getenv
  x/3x 0x19763e17c
● Hook后：
  disassemble -b -n getenv
  x/3x 0x19763317c
  
  通过上面的反汇编代码可以清晰地看见，函数头被改为：
  那么就可以用这个特征来进行函数头检测了。
  使用IDA对某著名小视频应用进行分析，发现它正是采用了此类方法，如图10-8所示。
  
  CheckFunHeader()就是最终的检测函数，
  第一个参数指定了待检测的函数地址，这里依次对多个函数进行检测。
  按〈F5〉键查看其伪代码，可以更清晰地看到对函数头的8个字节进行检测，以确定是否被Hook，如图10-9所示。
```

10.4 越狱检测
---------

```
很多应用为了确保安全性需要对越狱环境进行检测，
如果机器越狱了则不启用某些敏感功能（比如微信的指纹支付功能，在越狱状态下就会自动关闭）。
本节讲解的一些检测方法都是在各种应用中出现过的。
```

### 10.4.1 检测越狱商店及其附属文件

```
越狱环境几乎都安装了Cydia、Sileo及其附属文件，可以用下列代码检测：
```

### 10.4.2 尝试读取系统应用列表

```
如果设备已经越狱，就可以读取到系统应用列表的内容，以此来作为检测依据，示例如下：
```

### 10.4.3 检测 URLSchemes 是否有效

```
URLSchemes是苹果公司提供的用来跳转到系统应用或跳转到其他应用的一种机制。
这种机制给大家提供了一种检测越狱的思路：如果能打开Cydia或其他非官方应用，则说明已经越狱，利用“-(BOOL)canOpenURL:(NSURL *)url”方法来测试相应应用的URLSchemes是否有效就能判定。
以Cydia.app为例，先进入/Applications/Cydia.app目录，然后搜索“CFBundleURLName”，看到URLSchemes为cydia：
对应的检测代码如下：
```

10.5 完整性检测
----------

```
完整性检测可以确认目标文件是否被脱壳、是否被静态注入、内容是否被修改、是否被重签名等。
常见的方式有加载命令检测、代码段检测和签名信息检测。
```

### 10.5.1 加载命令检测

```
为了使未越狱的设备也能顺利使用插件，通常会在LoadCommand（加载命令）中增加一个LC_LOAD_DYLIB或者LC_LOAD_WEAK_DYLIB的方式来指向自己的动态库路径，从而实现注入功能，这种方式通常也称为“静态注入”。
加载命令检测即检测Mach-O文件的LoadCommand中的LC_LOAD_DYLIB或LC_LOAD_WEAK_DYLIB是否存在异常，代码如下：
```

### 10.5.2 代码段检测

```
代码段检测技术在Windows平台上使用非常广泛，在iOS平台上同样适用。
此方法主要用来检测“__TEXT,__text”是否被修改（当然也可以检查其他的Section），示例如下：
其中，
&_mh_execute_header指向Mach-O在内存中的起始位置，
getsectiondata函数返回指定Section的内存地址及大小。
实际应用中可以将正确的Hash值存到服务器或者加密后存到本地，在进程启动时进行比对，如果不匹配则可以做一些逻辑处理。
```

### 10.5.3 签名信息检测

```
被修改的应用若要在非越狱机器上使用，必要的一个环节就是对其重签名。
签名信息检测就是检测LC_CODE_SIGNATURE中的特征信息（比如TeamID）是否和用户自己的相匹配，如图10-10所示。
示例代码如下：
```

10.6 代码保护
---------

```
为什么要谈代码保护呢？
由于Objective-C的动态特性，导致class-dump等工具可以直接导出目标程序的头文件及方法名等。
在大多数情况下，变量或者方法的命名都有一定的可读性，由于这些信息的暴露，给逆向工程带来了极大方便。
简单地说，对代码进行保护就是不想暴露过多的信息给逆向研究人员。
代码保护和反调试通常相互配合使用。

iOS上使用得最多的代码保护手段是“混淆保护”，也就是将本来可读的代码转换成一种功能上等价，但是难以阅读和理解的代码，通俗地说就是“将简单问题复杂化”。
在iOS平台上，早期使用OLLVM（Obfuscator-LLVM）进行混淆保护较为普遍。

得益于LLVM的设计，OLLVM适用LLVM支持的所有语言（C、C++、Objective-C等）和目标平台（x86、x86-64、ARM、ARM64、Thumb等），
其代码托管在GitHub上：https://github.com/obfuscator-llvm/obfuscator。
遗憾的是，OLLVM的作者在后期转向了商业项目strong.protect，也就停止了代码的维护。

目前OLLVM仅支持LLVM4.0，因此笔者推荐由Naville开发的Hikari：https://github.com/HikariObfuscator/Hikari，它的功能更加强大和稳定。
Hikari的编译和安装十分简单，在终端输入如下命令，等待处理完成即可：

安装成功后可以在“Xcode”→“Toolchains”菜单下看到了“Hikari”命令，选中它即

Hikari目前提供了8种混淆选项，具体作用见表10-1。

在Xcode工程选项的“Build Settings”中根据需要添加上述选项即可，如图10-12所示。

另外，Hikari还额外提供了一个“-enable-allobf”选项，用于启用以上所有功能。
```

10.7 本章小结
---------

```
本章从调试器对抗、注入对抗、Hook检测、越狱检测、完整性检测及代码保护等方面讲述了iOS平台的各种应用安全保护技术。
随着技术的进步，新的检测手段也会逐步出现，只有不断地学习各种新知识才能面对未来的挑战。
```