> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.chinaunix.net](http://blog.chinaunix.net/uid-69947851-id-5825875.html)

> 在描述了《

    在描述了《[](http://blog.chinaunix.net/uid-69947851-id-5825847.html)[Linux 内核之 execve 函数](http://blog.chinaunix.net/uid-69947851-id-5825847.html)》之后，我发现要真正的理解 start_thread 函数的作用，我不得不提一下 C 语言是怎么转换成汇编的，以及寄存器在汇编语言中的操作规范和原则。本文主要简单说明一下寄存器在 ARM 32 位中的一些使用基本常识（64 位 ARM 以后介绍）。  
    首先 ARM 有许多寄存器（这里说的 ARM 32 位，指的是 arm cortex A 系列），如下图：  
![](http://blog.chinaunix.net/attachment/201910/11/69947851_1570762117MO88.jpg)  
    从图中可以看出（图选自于《cortex_A_series_PG.pdf》），32 位 arm 的 R0 - R7 为低端寄存器（Thumb16 模式下，只能使用 R0-R7，R13,R14,R15 这几个寄存器），这在所有 ARM 的工作模式下是共享的（ARM 有 7 种工作模式：Usr, Sys, FIQ, IRQ, ABT, SVC, UND，其中 MON 和 HYP 我们暂时不计入考虑，大部分操作系统工作于 SVC 模式下，应用工作在 Usr 模式下面）。下面我们来看看各个寄存器的作用。  
    R0 寄存器： 通常用于函数传参（参数 1）或者普通寄存器或者函数返回值。  
    R1 寄存器： 通常用于函数传参（参数 2）或者普通寄存器。  
    R2 寄存器： 通常用于函数传参（参数 3）或者普通寄存器。  
    R3 寄存器： 通常用于函数传参（参数 4）或者普通寄存器。  
    R7 寄存器： 系统调用时，存放系统调用号，有时也用于作为 FP 使用。FP 又叫 frame pointer 即栈基指针，主要在函数中保存当前函数的栈起始位置，用于堆栈回溯。  
    R13 寄存器：R13 又名 SP，即栈指针寄存器，主要用于指向当前程序栈顶，配合指令 pop/push 等。栈主要用于存放局部变量，保存函数间调用的关键寄存器，如 LR。SP 可以是向上增长也可以是向下增长，通常我们 ARM 采用的向下增长模式，下图为一个函数调用时，栈的排布情况。

![](http://blog.chinaunix.net/attachment/201910/11/69947851_1570767453U9G8.png)

    R14 寄存器：R14 又名 LR，即链接寄存器，主要用于存放函数的返回地址，即当前函数返回时，知道自己该回到哪儿去继续运行，通常这个是和 BL/BLX/CALL 指令搭配，这几个指令被调用后，默认会自动将当前调用指令的下一条指令地址保存到 LR 寄存器当中。  
    R15 寄存器：R15 又名 PC，即程序寄存器，主要用于存放 CPU 取指的地址，记住是取指地址，不是当前运行地址。目前，ARM 是三级流水线，因此，当 CPU 在执行 S 指令的时候，PC 指向的是 S+2 指令。但是当手动向 PC 赋值，则是让 CPU 跳转到赋入的值 所代表的地址去运行。

注：通常 PC 指针指向的地址都是 4 字节对齐，即地址的 [1:0]位总是为 0，这也是我们说的 ARM 模式。现在很多 CPU 都支持混合编码即同时支持 ARM 指令和 Thumb 指令，因此为了区分 Thumb 指令，ARM 将 [0] 位设置成 1，即地址最低位如果是 1，表示当前指令是 Thumb 指令，否则为 ARM 指令。  
    Thumb（16）指令占用的空间通常比 ARM 指令少，但是 ARM 指令运行的效率通常要比 Thumb 更高，Thumb 模式到 ARM 模式可以通过带 X 的跳转进行切换，如 BLX, BX 跳转指令（Thumb 分为 Thumb16 和 Thumb32）。

   上面说了寄存器的情况，下面说说在不同模式下，程序返回时，CPU 应该运行的地址：  
点击 (此处) 折叠或打开

1.   P1             P2           P3       
2.   |               |            |
3.   v               v            v
4.  CPU 执行       CPU 译码       CPU 取指（PC）

    上图为 CPU 的三级流水线：执行，译码，取指。PC 总是指向 CPU 取指的地址。

1、函数调用 返回  
点击 (此处) 折叠或打开

1.  MOV R0, #0  
    
2.  BL test  
    
3.  MOV R1,R0

    当第 2 行语句执行后，程序进入 test 函数运行，此时，LR 寄存器保存的是第 3 行的地址，因此，当 test 执行结束后，我们也希望继续运行第 3 行地址，所以 PC 应该直接赋值成 LR 的值：mov pc, lr

2、系统调用和未定义指令异常返回  
点击 (此处) 折叠或打开

    当执行 S1 指令的时候，触发了系统调用或者未定义指令（系统调用和未定义还没有执行完成，因此执行指令依然是 S1 没有更新），此时 PC 指向 S3（PC 始终指向正在取指的值），LR 的值为 PC - 4（ARM 模式）。因此，返回的时候，我们希望从 S2 开始运行，因此，PC 应该赋值为：mov pc, lr

3、FIQ 和 IRQ 异常返回  
点击 (此处) 折叠或打开

    当执行 S1 指令时，发生了中断（中断会等到 S1 指令执行结束后才响应，因此执行指令和 PC 都已经更新，为 S2 和 S4)，此时 PC 指向 S4，LR 的值为 PC-4 即 S3。因此，返回的时候，我们希望程序从 S2 开始运行，故，PC 应该赋值为: subs pc, lr, #4。

4、取指异常返回

    当执行 S1 指令时，发生了取指异常（取指异常发生在指令获取阶段，但是这个需要在执行这个错误指令的时候才会触发异常），此时 S1 就应该是这个取指异常的指令，PC 为 S3, LR 为 PC - 4 即 S2。因此，我们希望异常发生返回进行重新取指，所以 PC 应该赋值为 S1 的值即：subs pc, lr, #4。

5、数据访问异常返回  
点击 (此处) 折叠或打开

    当执行 S1 指令发生数据访问异常的时候，访问异常是发生在指令结束后，此时正在执行的指令为 S2，PC 为 S4， LR 为 PC-4 即 S3。因此，我们希望返回重新去取指访问数据，所以 PC 应该赋值为 S1 的值即：subs pc, lr, #8

    上述说完了 LR 和 PC 关系和取值，下面继续说关于 FP 的堆栈回溯功能， 如图：

![](http://blog.chinaunix.net/attachment/201910/11/69947851_15707732991z9d.jpg)

    上图是一个栈内容，函数调用栈为：

点击 (此处) 折叠或打开

1.  static int b(void)
2.  {
3.      return 0;  
    
4.  }
5.    
    
6.  static int a(void)
7.  {
8.      b();  
    
9.      return 0;  
    
10.  }
11.    
    
12.  static int t(void)  
    
13.  {  
    
14.      a();  
    
15.      return 0;  
    
16.  }

    通过上两图，我们假设在函数 b 里面发生了异常，比如是 SEGV 异常。  
1、通过读取寄存器 R13 和 R7 我们可以得到 R13 = 0x0800（栈顶）, R7 = 0x1000。  
2、通过栈的布局情况我们了解到，FP + 4 为上一个函数的返回地址 LR。在 b 崩溃的时候，LR 的值是 * 0X1004 = 0x300，即这个 0x300 就是 a 函数调用 b 函数的时候的下一条指令地址。  
3、通过栈的布局情况我们了解到，fp 则存放的是上一个函数 fp 的地址。因此，我们可以拿到 a 函数的 fp 地址：*0x1000 = 0x2000。  
4、重复 2 3 步骤，我们可以获取到 t 函数调用 a 函数的时候的下一条指令地址:0x500。  
因此，崩溃时候的调用栈是：  
点击 (此处) 折叠或打开

1.  b 函数  
    
2.      0x300 (a 函数)  
    
3.          0x500（t 函数）

    不管函数调用多少层，都可以用同样方法，一直找到最上层调用者。堆栈回溯的前提是：编译的时候 不能禁用 FP 功能 (gcc 编译的时候不要添加 - fomit-frame-pointer 参数，否则堆栈回溯会有问题)。

    我们从上面已经知道了寄存器的常用方法，下面我们通过一段 hello 程序来进一步说明，程序源码如下：  
点击 (此处) 折叠或打开

1.  #include <stdio.h>  
    
2.    
    
3.  static int main_test(int number)  
    
4.  {  
    
5.      int i = 1000;  
    
6.    
    
7.      for (;i > 0; i--)  
    
8.          number += i % 10;  
    
9.    
    
10.      return number;  
    
11.  }  
    
12.    
    
13.  int main (int argc, char *argv[])  
    
14.  {  
    
15.      printf ("Hello World\n");  
    
16.    
    
17.      return 0;  
    
18.  }

执行：arm-linux-gnueabihf-gcc -marm -o hello-2 hello-2.c  -fno-omit-frame-pointer 生成 hello 可执行文件（ELF 格式），再使用 arm-linux-gnueabihf-objdump -d hello > hello.s 得到对应的 ARM 32 位汇编代码。下面，我们将看看一个 C 程序转换成汇编后的工作情况，如下：

点击 (此处) 折叠或打开

1.  Disassembly of section .plt:
2.    
    
3.  82c0:   e28fc600    add ip, pc, #0, 12
4.      82c4:   e28cca08    add ip, ip, #8, 20  ; 0x8000
5.      82c8:   e5bcf324    ldr pc, [ip, #804]! ; 0x324
6.      82cc:   e28fc600    add ip, pc, #0, 12
7.      82d0:   e28cca08    add ip, ip, #8, 20  ; 0x8000
8.      82d4:   e5bcf31c    ldr pc, [ip, #796]! ; 0x31c
9.      82d8:   4778        bx  pc
10.      82da:   46c0        nop         ; (mov r8, r8)
11.      82dc:   e28fc600    add ip, pc, #0, 12
12.      82e0:   e28cca08    add ip, ip, #8, 20  ; 0x8000
13.      82e4:   e5bcf310    ldr pc, [ip, #784]! ; 0x310
14.      82e8:   e28fc600    add ip, pc, #0, 12
15.      82ec:   e28cca08    add ip, ip, #8, 20  ; 0x8000
16.      82f0:   e5bcf308    ldr pc, [ip, #776]! ; 0x308
17.  000083cc <main_test>:  
    
18.      83cc: e52db004 push {fp} ; (str fp, [sp, #-4]!)  
    
19.      83d0: e28db000 add fp, sp, #0  
    
20.      83d4: e24dd014 sub sp, sp, #20  
    
21.      .............
22.      8434: e3530000 cmp r3, #0  
    
23.      8438: caffffea bgt 83e8 <main_test+0x1c>  
    
24.      843c: e51b3010 ldr r3, [fp, #-16]  
    
25.      8440: e1a00003 mov r0, r3         # 返回值赋值给 r0  
    
26.      8444: e28bd000 add sp, fp, #0  
    
27.      8448: e8bd0800 ldmfd {fp}  
    
28.      844c: e12fff1e bx lr              # 返回 main 函数  
    
29.    
    
30.  00008450 <main>:  
    
31.      8450: e92d4800 push {fp, lr}  # 将 lr 和 fp 压栈
32.      8454: e28db004 add fp, sp, #4  # 设置新的 fp 地址 (这里的 fp 位置可能和上面描述有所不同，但原理一样)  
    
33.      8458: e24dd008 sub sp, sp, #8  # 开辟局部变量地址空间  
    
34.    
    
35.      845c: e50b0008 str r0, [fp, #-8]  # 给局部变量赋值 处置，这里 fp -8 是 argc  
    
36.      8460: e50b100c str r1, [fp, #-12] # 给局部变量赋值 处置，这里 fp -12 是 argv  
    
37.    
    
38.      8464: e30804d4 movw r0, #34004 ; 0x84d4  # 初始化函数的第一个传参，r0  
    
39.      8468: e3400000 movt r0, #0  
    
40.      846c: ebffff93 bl 82c0 <_init+0x20>     # 这里利用 0x82c0 间接跳转到 main_test 函数  
    
41.      8470: e3a03000 mov r3, #0  
    
42.      8474: e1a00003 mov r0, r3                # 将返回值 赋值给 r0, 相当于 return 0;  
    
43.      8478: e24bd004 sub sp, fp, #4            # 还原栈  
    
44.      847c: e8bd8800 pop {fp, pc}              # 弹出 上一个函数的 fp 和 lr 返回地址到 pc
45.    
    

     以上只对 main 函数的调用情况做出了说明。本章的内容，以后再内核的上下文切换、内核异常等问题的时候会用到。上下文切换在以后会单独讲解。  
 

阅读 (6104) | 评论 (2) | 转发 (0) |