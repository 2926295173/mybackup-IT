> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7028807205205835790)

第 11 章 协议安全
===========

```
在逆向工程中，有时需要研究应用与服务器之间的各种交互逻辑，从而达到一些自动化的目的，这种分析通常被称为应用通信协议分析（以下简称“协议分析”）。
例如市面上出现的各种“脱机外挂”及“xx视频点赞工具”等，都是对应用进行了协议分析制作而成的工具，因此协议的安全问题也是不容小觑的。

协议分析属于比较高阶的逆向工程技术，需要掌握的知识点也比较多，除了前面章节的所有知识点以外，还需要了解HTTP、TCP/IP、数据交换格式等，由于篇幅有限，这些内容不可能在本书全部讲述，请读者查阅有关资料。

协议分析过程中最重要的环节莫过于抓包分析及各种算法识别，本章在讲解工具使用的同时，也会穿插一些实例。
```

11.1 HTTP 分析利器：Charles
----------------------

```
Charles是一款支持HTTP、HTTPS的跨平台网络数据封包分析工具，该工具的实用性和强大功能对于iOS和Android开发人员来说久负盛名。

它的原理简单来说就是：通过将自己设置成网络代理服务器，充当一个“中间人”的角色，使得所有的网络访问请求都通过它来完成，从而实现了网络数据包的截取和分析。
从官网https://www.charlesproxy. com下载macOS版本的dmg文件安装即可。
需要说明的是：Charles是收费软件，仅提供30分钟试用时间，对于需要进行长时间抓包分析的研究人员来说，建议购买正版。
```

### 11.1.1 配置 Charles

```
抓取iOS设备的网络数据包前需要进行一些简单的配置。

（1）打开Charles的代理功能在“Proxy”菜单下（或者窗口右上方的齿轮按钮）选择“Proxy Settings”命令，
    设置“Http Proxy”中的“Port”为“8888”，
    并勾选“Enable transparent HTTPproxying”复选框，按图11-1完成设置。
    
（2）在iOS端设置代理要使iOS设备上的数据包能被Charles捕获，还需要将设备的网络代理设置为Charles启动的代理服务器。
    依次单击Charles中的“Help”→“Local IP Address”菜单项，获取本机IP，如图11-2所示。
    打开iOS设备的“设置”→“WiFi”页面，单击当前连接上的WiFi名称，可以看到底部有个“HTTP代理”的设置项。     切换到“手动”选项卡，将“服务器”设置为本机IP（例如笔者这里是“192.168.45.192”），“端口”设置为“8888”，如图11-3所示。
    设置完成后，当有网络请求发起时，Charles会弹出设备请求连接的窗口，此时单击“Allow”按钮，就能捕获到iOS设备发出的网络请求了。
```

### 11.1.2 修改数据包

```
在分析应用协议的过程中，有时需要测试一下请求的参数不同是否会返回不同的结果，
或者需要服务端返回不同结果来验证对数据的处理是否正确，由于没有服务端后台的控制权，问题似乎变得棘手了，但是Charles提供了一些高级功能，使这一切又变得简单起来。

它不仅可以修改请求参数，还能修改服务器返回的数据，非常方便。
Charles提供了多种方法进行修改，下面以应用协议分析中常用的两种来进行讲解。
```

```
1.Breakpoints
  Breakpoints用来对某个网络请求添加断点，中断后可以修改数据，然后再继续发送请求。
  下面用酷我音乐来演示这样一个功能：搜索“dj舞曲”相关的歌曲，通过修改请求数据，让服务器实际返回“beyond”相关的歌曲列表。
  打开应用后输入关键字“dj舞曲”进行搜索，Charles将捕获到一个请求地址，在该地址上单击右键，在弹出的快捷菜单中选择“Breakpoints”命令，如图11-4所示。
  再次用“dj舞曲”关键字进行搜索，Charles会触发断点。
  打开“Edit Request”选项卡，选择“URL”，在这里可以修改当前请求的参数。
  这里将“dj舞曲”改为“beyond”，然后单击“Execute”按钮，就能发起修改后的搜索请求了，如图11-5所示。
  此时已经根据修改后的参数返回了所有“beyond”相关的歌曲记录。
  这里顺便把这份JSON数据保存下来，方便下一步演示Map功能：在“JSON Text”区域单击右键，选择“Save Response”命令后选择保存位置即可，如图11-6所示。
  使用断点功能修改服务端返回的数据与上面类似，此处不再详述。
```

```
2.Map
  Map功能将某个网络请求进行重定向，用重定向后的内容来响应请求的内容，也可以将其理解为网络层的“Hook”。Map分为Map Local和Map Remote，两者都是进行重定向操作，它们的区别如下。
  ● Map Local：将某个网络请求重定向到本地某个文件。
  ● Map Remote：将某个网络请求重定向到另一个网络请求。
  还是用酷我音乐来做演示，上一步是用断点功能修改请求，让其返回指定数据，属于被动型，
  这次用Map功能来固定返回值，使得不管搜索什么关键字都返回“beyond”相关的歌曲数据，这属于主动型。
  单击目标请求，然后选择“Map Local”命令，如图11-7所示。
  在弹出的对话框中选择需要映射的本地文件，设置映射规则，如图11-8所示。
  此时用任何关键词进行搜索，都将返回固定的JSON内容。
```

### 11.1.3 重放数据包

```
重放数据包有两个作用：
  对于开发人员来说，可以用来测试服务器压力；
  对于协议分析来说，可以确定某个请求是否受到时间戳等因素的干扰，从而快速排除一些字段值。
在需要测试的网络请求上单击右键，在随后弹出的菜单中，与重放相关的命令有两个：“Repeat”和“Repeat Advance”，
  前者仅重放一次，后者可以根据自己的需要进行配置。
  这里选择“Repeat Advance”命令，在弹出的对话框中可以设置重放次数和并发数量，例如这里笔者设置对某数据包重放10次，如图11-9所示。
  另外，“Repeat delay(ms)”一栏还可以设置每次的重放间隔，单位是毫秒。
```

### 11.1.4 模拟弱网络

```
在开发应用的时候可能想要模拟一下弱网络的情况，Charles提供了这个功能，
打开菜单“Proxy”→“Throttle Settings”，会弹出图11-10所示的对话框。

勾选“Enable Throttling”复选框，在“Throttle preset”下拉列表框中可以选择各种网络类型，然后设置参数。
● Bandwidth：宽带的上行、下行数据传输速度。
● Utilisation：带宽可用率。根据实际情况调整。
● Round-trip latency：请求往返延迟。衡量客户端和服务端之间的第一次往返通信的延时数，单位是毫秒。
● MTU：最大传输单元。也就是传输的TCP数据包的最大尺寸，以便更真实地模拟TCP层每次传输的分包情况。
● Releability：连接的可靠性。这里指的是10kB的可靠率，用于模拟网络不稳定。
● Stability：连接的稳定性。主要用于模拟移动网络。
● Unstable quality range：不稳定性范围。此处设置主要配合“Stability”选项使用。

如果要对指定请求进行模拟，需要勾选“Only for selected hosts”复选框，然后单击“Add”按钮添加参数。
```

### 11.1.5 HTTPS 抓包

```
Charles本身是一个代理服务器，对于普通的HTTP请求，其数据本身没有经过再次加密，因此作为代理可以知道客户端发送到服务端的请求内容，以及服务端返回给客户端的数据内容，这也就是抓包工具能够将数据传输内容直接展现出来的原因。

对于HTTPS请求，由于数据都经过了加密，如果代理服务器什么都不做，就无法获取到其中的内容。
现在尝试用Safari打开https://www.chinapyg.com，会发现Charles并不能如期显示出数据包内容，而是显示一把锁的标志，如图11-11所示。

为了实现HTTPS数据的截获，需要先安装Charles的根证书，依次单击“Help”→“SSL Proxying”→“Install Charles Root Certificate on a Mobile Device orRemote Browser”，如图11-12所示。

之后会弹出一个对话框提示如何在设备上安装根证书，如图11-13所示。

在iOS设备上用Safari打开chls.pro/ssl，顺利的话会跳转到“安装描述文件”的页面，此时会用红色提示“尚未验证”，单击“安装”按钮按照提示操作即可。

成功后会用绿色提示“已验证”，如图11-14所示。

注意，如果当前的设备是iOS 11及以上版本的系统，还需要多一步配置，否则还是会抓不到HTTPS包：依次打开“设置”→“通用”→“关于本机”→“证书信任设置”，在“针对根证书启用完全信任”下找到“Charles”开头的证书并设置信任，如图11-15所示。

经过上面的设置之后，再来试一下。
用Safari打开https://www.chinapyg.com，会发现还是显示一把锁。
其实这里只需要在网址后面单击右键，然后选择“EnableSSL Proxying”即可，如图11-16所示。

经过上面一番操作后，再次刷新Safari，这次终于看到熟悉的明文数据了，如图11-17所示。

如果要对整个域名都启用SSL代理，可以单击“Proxy”→“SSL Proxying Settings”菜单项，单击“Add”按钮，按照图11-18进行配置即可。
```

### 11.1.6 绕过证书校验

```
按照上一小节设置好Charles后，一般的HTTPS请求都可以抓取了，若应用在代码里面进行了HTTPS证书验证（例如WhatsApp），则需要绕过证书验证才能抓到明文包。

这里要使用ssl-kill-switch2插件来做这件事情。到https://github.com/nabla-c0d3/ssl-kill-switch2/releases下载最新版的deb包（当然也可以下载源码自行编译），复制到设备里面用dpkg安装，最后重启SpringBoard即可。具体操作过程如下：
  scp -P2222 ./com.nablac0d3.sslkillswitch2_0.13.deb root@localhost:/tmp
  dkpg -i com.nablac0d3.sslkillswitch2_0.13.deb
  killall SpringBoard
  
安装完毕后会在“设置”页面出现“SSL Kill Switch 2”选项，如图11-19所示。
单击“SSL Kill Switch 2”后将“Disable Certificate Validation”开关开启即可，如图11-20所示。

此时再尝试抓包测试，一切正常！
```

11.2 TCP/IP 分析利器：Wireshark
--------------------------

```
Wireshark（前身是Ethereal）是目前全世界最流行的网络分析工具。
它免费、开源且跨平台，可以捕捉网络中的数据，并为用户提供关于网络和上层协议的各种信息。
与Charles相比，它不但可以抓取HTTP包，还可以抓取TCP和UDP包。
在其官网https://www. wireshark.org/直接下载安装包即可安装。
```

### 11.2.1 创建远程虚拟接口

```
而Wireshark的原理则完全不同，它是直接捕获从网卡出来的所有数据包。

iOS 5以后，苹果引入了RVI（Remote Virtual Interface，远程虚拟接口）的特性，
它只需要将iOS设备使用USB数据线连接到macOS上，
然后使用rvictl工具在macOS中建立一个远程虚拟接口，
接着就可以利用Wireshark对创建的接口进行抓包分析了。

这种方法直接捕捉iOS设备上的网络数据，其优点也是显而易见的：无论是WiFi还是2G/3G/4G等其他网络类型都可以捕捉到。下面讲述其方法。
  1）将iOS设备通过USB连接，打开Xcode，单击“Windows”→“Devices”菜单项，找到连接设备的Identifier，如图11-21所示。
  2）在macOS终端中使用rvictl工具，将上面获取的Identifier作为参数传入，创建远程虚拟接口，命令如下：
   rvictl -s a666666
   
打开Wireshark就可以看到rvi0，如图11-22所示。

如果需要停止该接口，可以使用-x参数：
   rvictl -x a666666
```

### 11.2.2 认识 Wireshark

```
在Wireshark中双击rvi0接口，即可监控iOS设备的所有网络数据，如图11-23所示。

从上到下可以将主界面分为4个主要部分。
第①部分是工具栏，主要控制开始抓包、停止抓包、重新抓包、分组跳转、分组查找等。
下面的文本框是过滤器，可以根据指定的条件过滤需要的数据。

第②部分是数据包列表，从左到右分别是
  序号、时间、源地址、目标地址、协议类型、数据长度、描述信息。
  
第③部分是某个数据包的详情，充分展示了不同协议类型的请求格式、包的详细信息，能够帮用户理解通信的各个环节。

第④部分是某个数据包的二进制数据，在第③部分选择不同的结构，这里对应的二进制数据就会高亮显示，以便进行更好的分析。
```

### 11.2.3 TCP 抓包分析示例

```
接下来以登录微信为例，对一个完整的TCP请求进行分析。
先在过滤器中输入“ip.addr==192.168.45.48”，排除一些干扰包。

启动微信，输入账号密码进行登录，在捕获到的数据包列表中选择某列数据，在其右键快捷菜单中选择“追踪流”→“TCP流”，如图11-24所示。

接下来Wireshark会自动设置过滤条件（如本次是“tcp.stream eq 1”），列出完整的TCP通信过程数据，如图11-25所示。

现在针对抓到的数据包来简单分析TCP的通信过程。

● No.12：第一次握手。客户端将标志位SYN置1，随机产生一个序列号Seq=x，并将该SYN报文发给服务端，客户端此时进入SYN-SENT状态，等待服务端确认。

● No.13：第二次握手。服务端收到客户端的请求，回复一个确认信息（ACK=x+1）给客户端，接着再次向客户端发送一个SYN包（seq=y）建立连接请求，此时服务端进入SYN_RCVD状态。

No.14：第三次握手。客户端收到服务端的确认（SYN+ACK报文）后，要向服务端发送ACK，此包发送完毕后客户端和服务器端进入ESTABLISHED状态。

完成三次握手后，就可以发送数据了，
No.15～No.21表示客户端和服务端之间的数据传输和确认。
单击PSH标记的数据，就能在下方十六进制区域看到传输的实际数据。
由于微信是长连接，所以不会出现“FIN”关闭连接的标记。

在实际传输中，数据包被分为3个大结构：
  IP头、TCP头、传输数据，这些结构涉及TCP的底层机制，与应用通信协议分析并没有直接关系，大家不需要太关心，感兴趣的读者可以自行查阅相关文档。
  
  此处只要关心“Tcp payload”即可，它是实际传输的业务数据，如图11-26所示。
  
  除了用十六进制方式查看数据外，Wireshark还提供了ASCII、C Arrays、UTF-8等8种查看方式，如图11-27所示。
```

### 11.2.4 数据包过滤

```
在对目标应用的某个功能进行抓包分析时，可能会得到很多冗余的数据，如果不加入一些过滤规则，就很难简单直观地得到需要的信息。

Wireshark中提供了非常强大的过滤器，用好这个功能可以让数据包分析更加快捷，上一小节已经简单体验了一下如何用IP进行过滤。

实际上，Wireshark有两种过滤器，分别是捕获过滤器和显示过滤器。
捕获过滤器可以在捕获数据包的时候就进行过滤，显示过滤器在显示的时候进行过滤。这两种过滤方式的优势显而易见：

第一种可以减少捕获的数据包数量，以避免产生过大的日志文件，从而减少系统的负荷；
第二种可以捕获完整的数据包，允许用户在日志文件中迅速准确地找到所需的记录，但会加重系统负荷。

两种过滤器使用的语法有些不同，下面分别进行介绍。
```

```
1.捕获过滤器依次单击“捕获”→“选项”，在弹出的窗口中定位到rvi0，如图11-28所示。

在过滤器对话框中可以输入过滤规则。
图11-28中例子的意思是：捕获源IP为192.168.45.48、端口号为80的TCP数据包。
捕获过滤器的基本语法为“ProtocolDirection Host(s) Value”。

1）Protocol：常用值有ether、ip、arp、tcp、udp、http、ftp等。
   如果没有特别指明是什么协议，则默认使用所有支持的协议。

2）Direction：常用值有src、dst、src and dst、src or dst。
   如果没有特别指明来源或目的地，则默认使用“src or dst”作为关键字。例如：host 192.168.45.48与src or dst host 192.168.45.48是一样的。
   
3）Host(s)：常用值有net、port、host。
   如果没有特别指明该值，则默认使用“host”作为关键字。例如：src 192.168.45.48与src host 192.168.45.48相同。
   
4）Value：端口号。
   Wireshark支持多条语句结合，中间用逻辑运算符连接，见表11-1。
   
   在实际书写过程中可以使用英文写法，也可以使用C语言写法，Wireshark都是支持的。
   需要注意的是，“not”具有最高的优先级，“or”和“and”具有相同的优先级，运算时从左至右进行。
```

```
下面讲解几种常用的过滤规则。
（1）主机名和地址过滤Wireshark可以根据主机的属性进行过滤，包括MAC地址、IPv4或者IPv6等过滤规则，例如：
 #根据IPv4过滤
 host 192.168.45.48
 
 #根据IPv6过滤
 host fe80::857:lfff:fe8c:d285
 
 #根据MAC地址过滤
 ether host 192.168.45.48
 
 #根据流出传输方向过过滤
 src host 192.168.45.48
 
 #根据流入传输方向过滤
 dst 192.168.45.48(host限定词可以省略)
```

```
（2）端口过滤
    端口过滤通常被用来过滤使用已知端口的服务和应用。
    比如可以监控捕获80端口的流量：
    port 80
```

```
（3）协议过滤
    设置协议过滤器后，只会捕获相应协议或排除某协议的数据包，例如：
    #捕获TCP协议数据包
    tcp
    #捕获ipv6协议以外的数据包
    !ip6
```

```
2.显示过滤器
  读者应该还记得，前面学习使用Wireshark的过程中，已经接触过显示过滤器（“ip.addr==192.168.45.48”），可以发现它的语法和捕获过滤器还是有一些差别的。
  本部分就来讲解一下基本语法和常规用法（见表11-2）。

  表11-2中例子的意思是：捕获IP为192.168.45.48的被动模式ftp数据包。
  单击过滤器文本框右边的“表达式”，可以列出所有支持的协议，如图11-29所示。
  
  显示过滤器除了可以使用逻辑运算符以外，还支持6种比较运算符，见表11-3。
  
  显示过滤器的规则灵活多变，下面仅讲解几种常用的过滤规则，其他的规则请参考官方文档。
  
（1）协议过滤
 #显示TCP、DNS、ICMP数据包
 tcp ｜｜ dns ｜｜ icmp
 
（2）协议属性值过滤
 #根据来源或目的TCP端口为80的数据包
 tcp.port == 80
 
 #显示目的TCP端口号为80的数据包
 tcp.dstport = 80
 
 #根据源IP为192.168.45.48的数据包
 ip.src == 192.168.45.48
 
 #根据目标IP为192.168.45.48的数据包
 ip.dst == 192.168.45.48
 
 #显示www.chinapyg.com域名的POST请求数据包
 http.request.method == "POST" && http:host == "www.chinapyg.com"
   
 提示：在过滤器文本框中输入规则时，如果语法有误，会显示红色，如正确，会显示绿色。
```

11.3 常见算法识别
-----------

```
在协议分析过程中总会遇到形形色色的加密算法，如果不加以识别，则会走许多弯路。

常见的算法可以归类为压缩算法、摘要算法、对称加密算法和非对称加密算法。

这些算法的实现原理这里暂时不予深究，因为有很多专业的第三方库已经完整实现了这些算法，只要会用即可。

表11-4列举了笔者在工作过程中使用的一些优秀第三方库及其官网。

表11-4 第三方库及其官网
OpenSSl https://www.openssl.org
Crypto++ https://www.cryptopp.com
LibTomCrypt http://www.libtom.net/LibTomCrypt

在笔者逆向过的应用中，发现有90%都使用了OpenSSL库来完成加密算法，所以下面的分析都基于OpenSSL进行，读者最好对其中常用算法的使用方法有所了解，必要时可以查阅官方文档。
```

### 11.3.1 压缩算法

```
在应用开发过程中，随着业务的复杂度增加，难免会遇到大量数据交换，为解决这个问题从而优化网络传输，通常会使用压缩算法将数据包处理后再传输。

常用的压缩算法都基于zlib库，下载地址为https://zlib.net，识别zlib可以从程序和数据两方面分析。
```

```
1.从程序上识别

因为iOS自带了zlib动态库，开发人员可以直接使用，这时只要使用IDA查看导入表，就能看到/usr/lib/libz.1.dylib。

接着可以根据zlib.h头文件中的导出函数名称进行搜索，找到后再查找交叉引用即可定位关键点，如图11-30所示。

对于Objective-C函数，如果没有被混淆，则可以搜索“zip”“gzip”关键字，找到后再对其进行Hook追踪、动态调试等，即可找到关键点，如图11-31所示。

这里顺便提一句，按照关键字搜索这一方法对后面的其他算法识别也是有用的，笔者将它称为“通用识别方法”。

它的识别方法相对简单，如无特殊说明，后续不再对此方法进行讲述。

如果程序恰好使用了zlib静态库怎么办呢？这时可以搜索zlib的版本号来确定，这样做是有原因的，查看zlib.h头文件会发现以下代码：

如果读者熟悉zlib的使用流程，就会知道这些是必要函数，而这些函数里面都有个ZLIB_VERSION宏，所以通过搜索这个版本号字符串就能确定是否使用了zlib，再根据zlib源代码结合上下文分析，然后在IDA中将这些函数重新命名。

因为zlib的版本号为1.2.x（目前最新版是1.2.11），所以读者可以按照版本号大小从后向前尝试搜索，如图11-32所示。
```

```
2.从数据特征识别

每种数据格式都会有一定的特征，zlib压缩后的数据也不例外，
第一个字节一定是0x78，第二字节表示压缩级别，
例如下面3组使用zlib压缩的数据：

虽然一个样本数据的第一字节是0x78并不能证明数据使用了zlib压缩，
但对比和观察多个同类型的样本，如果发现数据开头都是0x78，那么就可以确定数据使用了zlib压缩。
如果数据开头两字节是0x1F和0x8B，则是gzip压缩，

例如下面3组数据：
```

### 11.3.2 摘要算法

```
摘要算法（也称为散列算法/哈希算法）仅用于验证数据的完整性和唯一性，不管原始数据有多长，得到的hash值都是固定长度。

在iOS应用中常用的摘要算法为
MD5及SHA系列（包括SHA1、SHA256、SHA384、SHA512）。
```

```
1.iOS自带算法的识别在CommonCrypto/CommonDigest.h头文件中提供了几乎所有的摘要算法，
  开发时直接使用即可，如图11-33所示。

  由于这些函数都由libSystem.B.dylib库导出，所以必然会有符号，这就为定位函数提供了帮助：直接在目标程序导入表中搜索这些函数名就能找到，如图11-34所示。
  
  之后双击即可定位到具体调用处，如图11-35所示。
```

```
2.OpenSSL中的摘要算法识别
在openssl/md5.h头文件中声明了MD5算法有关的函数：

OpenSSL库里面的摘要算法都形如“xx_Init”“xx_Update”“xx_Final”，使用时只要顺序调用这三个函数即可。

因此，只要找到上面三个函数中的任意一个，就能定位其他两个。

以MD5算法为例，笔者更趋向于先找MD5_Init，因为它最简单，实现如下：

所以在IDA里面看到图11-36所示的代码时，就说明找到MD5_Init了。

然后对此函数查找交叉引用，即可定位MD5_Update和MD5_Final，依次对它们进行重命名，结果如图11-37所示。

对其他的摘要算法，读者可以举一反三，找到头文件及算法的实现后，查找方法是一模一样的。
```

### 11.3.3 对称加密算法

```
所谓对称加密算法，是指加密与解密使用同样的密钥。
对称加密算法的优点在于效率高、算法简单、系统开销小，适合加密大量数据。
常用的有AES、DES、Blowfish等。
```

```
1.iOS自带算法识别在CommonCrypto/CommonCryptor.h头文件中提供了下列对称加密算法：
  开发人员通过调用CCCrypt函数，传入指定的参数，即可实现上述算法。

  CCCrypt函数的声明如下：
  因此识别这些算法也就简单了，在IDA中查找CCCrypt函数的引用，然后查看第二个参数alg（X1/W1寄存器）即可确定算法类型。
  图11-38所示为找到的AES算法。
  
  如果需要得到更加详细的参数（比如AES128、AES256及密钥等），可以对此函数进行Hook，将所有需要的参数都打印出来即可，代码如下：
```

```
2.OpenSSL中的对称加密算法识别
  本部分以AES为例讲解OpenSSL中的对称加密算法识别。
  如果符号没被去掉，可以通过搜索AES_encrypt、AES_decrypt函数来定位。
  如果符号被去掉了，那就只能通过AES初始化时的四张表来定位了。
  
  先在aes/aes_ecb.c里面查看AES_encrypt函数的实现：
  
  Te0～Te3就是这里需要的四张表，此时在IDA里面先切换到“Hex View-1”窗口，然后输入特征码，勾选“Find all occurrences”复选框后进行搜索，就会找到这些表，如图11-39所示。
 
  对找到的地址查找交叉引用，最终会找到调用处，然后将函数重命名为“AES_encrypt”，此处转换成了伪代码，方便识别，如图11-40所示。
 
 接下来找AES_decrypt就不需要这么麻烦了。在aes/aes_ecb.c源码里面查看到AES_ecb_encrypt函数的源代码如下：
 
 所以通过对AES_encrypt的交叉引用，就能快速定位AES_ecb_encrypt，然后AES_decrypt自然就定位到了，直接重命名即可，如图11-41所示。

这一部分的宗旨是让读者善于通过源代码来寻找规律，这样不至于摸不着头脑。
规律越多，定位的方式就会越快速。
```

### 11.3.4 非对称加密算法

```
如果通信双方需要实现信息的保密性、完整性、可用性，则需要采用非对称加密算法。

非对称加密算法需要两个密钥，即公开密钥（publickey）和私有密钥（privatekey），以下简称为“公钥”和“私钥”。

公钥与私钥是一对，
如果用公钥对数据进行加密，只有用对应的私钥才能解密；
如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。

因为加密和解密使用的是两个不同的密钥，所以这种算法叫作“非对称加密算法”。

iOS中常用的非对称加密算法主要使用RSA、ECC等。

本节以RSA算法为例进行讲解，ECC（ECDH）类似。
```

```
1.iOS自带算法识别

  iOS自带的Security.framework框架可以用来实现RSA加密、解密、签名与验签，主要使用四个函数：SecKeyEncrypt()、SecKeyDecrypt()、SecKeyRawSign()、SecKeyRawVerify()。
  
  在Security/SecKey.h头文件中可以找到函数定义，因此只需要在导入表中找到“Security”，即可搜索到这些函数，如图11-42所示。
```

```
2.OpenSSL中的非对称加密算法识别
  由于Security.framework框架中的函数使用比较烦琐且不跨平台，所以很多开发者选择使用OpenSSL中的RSA相关函数，其识别方式也是有规律可循的。
  OpenSSL中与RSA加密解密有关的函数实现位于crypto/rsa/rsa_crpt.c：
  
  读者应该注意到，单从这些函数根本无法提取任何特征，所以转而查看这些函数的调用方法。
  通过查阅官方文档和自带的例子，可以知道在调用这些函数前，一定会调用RSA_new或EVP_PKEY_get1_RSA函数来得到一个RSA对象。
  以RSA_new为例，在crypto/rsa/rsa_lib.c文件中找到其实现：
  
  在RSA_new_method函数里面有个RSAerr，这其实是个宏，可以在err.h中找到：
  
  类似的宏定义还有很多，OPENSSL_zalloc也是如此。
  __FILE__和__LINE__宏分别会打印出文件路径和行数，大家可以利用这些日志来定位。
  先在IDA中搜索“OpenSSL”来确定目标程序使用的具体版本，如图11-43所示。
  
  到https://www.openssl.org/source/old/下载相应版本的源代码，找到crypto/rsa/rsa_lib.c，可知RSAerr函数的调用位于143行。
  
  接着在IDA中搜索“rsa_lib.c”字符串查找交叉引用，会找到一个最后参数为143的ERR_PUT_error调用，这就位于RSA_new_method函数了。按照源代码可以将其他函数也重命名，完成后，如图11-44所示。
  
  定位到RSA_new_method函数后，往上回溯一级即为RSA_new函数，接着对RSA_new查找交叉引用，在附近的位置看到有五个参数的函数就是RSA的相关函数了，如图11-45所示。
  
  遗憾的是，前面提到的四个RSA加密与解密函数的参数都一模一样，所以无法精确判断它们到底是哪个函数，到此为止只能通过Hook或者动态调试来对它们进行确认。
  
  难道确实无法通过静态分析再排除一下吗？读者请继续往下看。
  OpenSSL中与RSA签名有关的函数实现位于crypto/rsa/rsa_sign.c：
  
  仍然通过文件名和行号来定位RSA_sign和int_rsa_verify，找到后就能定位出RSA_private_encrypt和RSA_public_decrypt了，
  如图11-46所示。笔者已经对照源代码将部分函数做了重命名处理。
  
  由于__FILE__和__LINE__宏的存在，给逆向工程定位算法带来了便利，同时也给应用带来了极大的威胁，因此新版OpenSSL里面增加一个OPENSSL_NO_FILENAMES宏，具体如下：
  
  OPENSSL_NO_FILENAMES宏默认是关闭的，如果需要启用则在编译时添加以下参数：
  ./Configure -DOPENSSL_NO_FILENAMES ...
```

### 11.3.5 利用插件识别

```
除了利用人工方式识别算法以外，还可以利用一些IDA的插件进行辅助分析。

笔者推荐一款名为“findcrypt-yara”的插件，它采用Python编写，依赖yara（强大的特征码匹配库），插件作者已经添加了一些算法特征码，也可以自行扩充。
```

```
1.安装方法
  先使用pip安装yara-python，然后从GitHub下载findcrypt-yara的最新源代码，将下载后的findcrypt3.py、findcrypt3.rules复制到IDA插件目录，具体如下：
  pip install yara-python
  git clone https://github.com/polymorf/findcrypt-yara.git
  cd finfcrypt3.py findcrypt3.rules /Applications/IDA\ Pro\ 7.0/ida.app/Contents/MacOS/plugins/
```

```
2.使用方法
  选择IDA菜单中的“Edit”→“Plugins”→“Findcrypt”，稍等片刻后就会显示出识别结果，双击某一行可以定位到相应的位置，如图11-47所示。
```

```
3.添加规则代码
  自带的规则文件有可能匹配不到所需的数据，这时候就要自己添加规则了，以图11-48所示的MD5算法的初始化特征码为例。

  编辑findcrypt3.rules文件，添加以下规则代码（笔者已经对这些规则代码添加了注释）：
  
  findcrypt3.rules里面完全是yara的语法规则，其中第③部分是最重要的特征码数据，可使用文本字符串、十六进制字符串及正则表达式。
  重新搜索，插件会将匹配到的特征码重命名为指定的规则名称，如图11-49所示。
  
  本节起到抛砖引玉的作用，在https://github.com/Yara-Rules/rules可以找到大量的规则文件。
  如果大家添加了更多的规则代码，欢迎到https://www.chinapyg.com讨论分享。
```

11.4 本章小结
---------

```
本章为对两个典型的抓包工具Charles及Wireshark进行了较为详细的实例讲解，
最后一部分讲解了各种常见加密算法的识别方法及笔者的一些心得体会。
```

第 12 章 实战 1：某著名社交 App 小程序格式分析
=============================

12.1 目标 App 介绍
--------------

```
本章的实验目标是一款著名的社交App，可以通过手机网络发送语音、图片、视频和文字等。它提供了小程序功能。
小程序可以在目标App主程序内被便捷地获取和传播，同时具有出色的使用体验。
它是以“wxapkg”为扩展名的文件，保存在目标App的沙盒目录下，如图12-1所示。

wxapkg文件就是目标App官方自定义的文件格式，没有现成的解包工具，如果要对别人的小程序源代码进行借鉴，则需要自行逆向wxapkg文件格式，然后编写解包工具，这正是本章要讲解的内容。
```

12.2 寻找切入点
----------

```
逆向任何一个程序都需要先寻找切入点，这已经成为一个惯例，本节从断点来入手。
试想一下，解包前是不是需要先读取wxapkg的二进制文件？用什么来读取更加方便呢？
笔者大胆猜测可能会用NSData来进行二进制操作，NSData有个“dataWithContents OfFile:”方法就是专门从文件读取数据的。
有了这个猜想，大家先把沙盒中的wxapkg文件删除，并将目标App运行起来，对“dataWithContentsOfFile:”方法添加正则匹配断点：

  breakpoint swet --func-regex datawithContentOfFile
  c

此时尽量别做其他操作（防止断点被干扰），进入一个小程序，期间会中断几次，每断一次就把x2寄存器打印出来观察文件路径，直到出现wxapkg文件时，打印调用栈，并使用第7章编写的LLDB脚本命令foff，找到IDA中的偏移地址，操作如下。

po $x2
bt
fooff 0x0000000100309ce8

在IDA中转到0x100231ce8地址，向上找到入口“[WAPackageInfoCacheLogicunpackPkg WithFilePath:unpackLib:]”，这就是切入点了，如图12-2所示。
```

12.3 分析文件结构
-----------

```
文件结构是文件存放在存储设备上的组织方法。
wxapkg文件也不例外，只有弄清文件结构才能编写工具来解读它。
```

### 12.3.1 分析伪代码

```
按〈F5〉键查看“[WAPackageInfoCacheLogicunpackPkgWithFilePath:unpackLib:]”的伪代码，发现逻辑比较简单，
先读取文件内容到NSData，在进行简单的判断后，
传入sub_100534E14函数进一步处理，关键代码如图12-3所示。

根据日志信息能确定sub_100534E14的功能是进行解压操作，所以将它重命名为“WAPackageInfoCacheLogic::UnpackPkg()”，
然后参考上下文信息修改参数名称及类型，如图12-4所示。
```

### 12.3.2 定义文件结构

```
进入“WAPackageInfoCacheLogic::UnpackPkg”函数后，发现IDA已经识别出了WXAPkg、WXAPkgInfo两个结构体，但是字段名还是var0、var1等，所以先静态地把IDA识别出的结构体命名修正，使其更有意义。
以WXAPkg为例。
右击“WXAPkg”，选择“Jump to local type”命令，如图12-5所示。

之后会到达WXAPkg的定义处，单击右键，在弹出菜单中单击“Edit”，会发现一些有意义的字段类型，根据其大致含义修改成对应的字段，如图12-6所示。

在修正结构体之后，就可以很清晰地知道wxapkg文件分为三部分：包头（PkgHead）、描述信息（PkgInfo）、文件数据（PkgData），如图12-7所示。
```

12.4 分析包头结构
-----------

```
任何一个文件格式的包头结构中通常都会包含重要的索引信息，需要重点分析。
本节将对包头结构进行详细分析。
```

### 12.4.1 推导包头大小

```
在IDA中修正结构体之后，伪代码已经清晰了很多，如图12-8所示。

其中，输入参数pkg_data_input被sub_102FF6C0C、sub_102FF6C00两个函数引用。
v8变量对应了sub_102FF6C0C函数的返回值，里面取了AutoBuffer->var0的值：
v9变量对应了sub_102FF6C00函数，里面取了AutoBuffer->var1的值：

AutoBuffer->var0和AutoBuffer->var1对应的数据已经无法静态分析出来了，接下来用LLDB来调试，先找到对应的偏移地址为0000000100534E68：

对0000000100534E68地址添加断点，然后单步跟踪并打印X0的数据，
最终确定sub_102FF6C0C函数的作用是获取wxapkg文件的数据，
sub_102FF6C00的作用是获取wxapkg文件的大小，调试过程的关键步骤如下。
 bo 0x0000000100534E68
 c
 ni
 x $x0
 ni 2
 po $x0
 po/x $x0

在IDA中将这两个函数分别重命名为
“AutoBuffer::GetData”和
“AutoBuffer::GetSize”，
将v8重命名为“data”，v9重命名为“size”。接着分析下面这几行代码。

这里分别从v11的1、5、9位置取了三个int值放到包头，
v11从v20而来，而v20与sub_102FF6B84函数有关系，进入该函数分析发现它是将输入参数打包成了AutoBuffer结构（var0包含了输入数据，var1包含了长度），v20传出的就是打包好的AutoBuffer结构。
笔者将sub_102FF6B84函数重命名为“AutoBuffer::Write”，其代码如下。

现在已经得出一个结论：包头占用了14字节，也就是说从wxapkg起始位置开始取14字节构成了包头，且第一字节、最后一字节未使用。

用010 Editor打开两个不同的wxapkg文件来观察一下，对比发现第一字节和最后一字节是固定的，分别为0xBE和0xED，这应该是两个标记，中间的12字节就是pkgHead.var0～pkgHead.var2所需的三个int值了，暂时还不知道这三个值的含义，待后面继续分析，如图12-9所示。
```

### 12.4.2 定义包头结构

```
根据上一节的推导，基本可以定义包头结构如下。

下面代码的含义是，如果var1+var2+sizeof（PkgHead）的值等于size就通过验证，这是个简单的数据大小校验：

取示例3.wxapkg的数据验证一下：
0x19E0（var1）+0x1ACBA7（var2）+0xE=0x1AE595，和前面的LLDB调试结果吻合，正是文件的总大小。

接下来分析这段代码：

这里再次调用了AutoBuffer::Write函数将数据写到v19，输入参数v12指向了data+14的位置，也就是紧接着包头后面的数据，大小为pkgHead.var1的值。

v19传递给接下来的sub_100534920函数，向上找v6看到它指向了&wxapkg->pkgInfo，由此可推断出var1是pkgInfo的长度，将它重命名为“pkgInfoLength”。

根据文件结构图推导var2就是pkgData的长度，将它重命名为“pkgDataLength”，最后的PkgHead结构图如图12-10所示。
```

### 12.5 分析描述信息结构

```
到目前为止，v19里面已经读取到了pkgInfo信息，
接着调用sub_100534920函数来进行解析，先将该函数重命名为“WAPackageInfoCacheLogic::ParserPkgInfo”，
经过精简和重命名变量后，关键伪代码如下。

之前已经进行过大量的函数重命名操作，使得上面代码的逻辑看起来非常清晰，甚至不需要动态调试就能分析出来了，笔者已经在几个关键的地方写了注释，可见前面工作的重要性。

“WAPackageInfoCacheLogic::ParserPkgInfo”函数最先取了4字节作为文件数量，紧接着就是每个文件的信息结构，包括文件名长度、文件名、文件偏移、文件大小。使用010Editor查看一下文件数据，如图12-11所示。

图12-11表示该wxapkg文件总共包含0xAE个文件，
第一个文件名长度为0x1B，文件名为“/we7/resource/icon/home.png”，文件偏移为0x19EE，文件大小为0x5E0。
可以用图12-12描述PkgInfo的数据结构。

此时用010 Editor从偏移0x19EE开始选择大小为0x5E0的数据，
即为第一个文件（/we7/resource/icon/home.png）的PkgData，如图12-13所示。

所有文件都是连续存放的，用图12-14可以描述PkgData的数据结构。
```

12.6 编写解包工具
-----------

```
有了前面的分析基础，是时候编写代码来遍历这些文件结构并解析出每个文件了。
笔者用C++编写解包工具，并且兼顾了Windows和macOS平台，在VC6和Xcode中编译通过。摘录关键部分如下。

编译完成后，以3.wxapkg为例来进行测试，解包后的文件内容如图12-15所示。

至此，目标小程序的文件格式分析以及解包工具的编写就完成了，希望读者多多练习，举一反三。
```

### 12.7 本章小结

```
本章先猜想了读取文件的方式，然后通过添加断点的方式找到切入点，从而推导出文件的结构，其中讲解了用IDA修正结构体的一点技巧。
紧接着按照文件结构图，顺序讲解了各部分的构成，最终完成了解包工具。
分析一个新的文件结构时，要善于观察，对多个同类型文件进行采样，找到异同点，然后对照着反汇编代码推测其结构。对于这种纯C语言代码的分析，需要读者积累一定的经验，对指针的使用了如指掌。
```

第 13 章 实战 2：某短视频 App 水印控制及配置开关分析
================================

13.1 目标 App 介绍
--------------

```
本章的实验目标是一款社交类App，通过它可以分享生活，同时也可以认识更多朋友，了解各种奇闻趣事。
用户可以从中选择歌曲，配以短视频，形成自己的作品。
目标App上的视频提供了下载功能，而且下载回来的视频都有水印，本章的目的就是分析目标App是如何实现这一功能的。
```

13.2 寻找切入点
----------

```
笔者发现，目标App内播放的视频并不存在水印，一旦保存到相册就出现了水印，这可能有两种情况。
 ● 水印在保存过程中由代码合成。
 ● 可能还存在另外一个无水印的播放地址。
 秉着先易后难的原则，采用抓包分析的方法先对后者进行求证。
```

### 13.2.1 抓包分析

```
打开Charles设置好代理，重新启动目标App任意播放一个短视频，会获得一个疑似视频链接的请求，将此链接直接复制到Safari浏览器中打开，发现显示内容正是设备上播放的无水印视频，如图13-1所示。
现在将视频保存到相册，再次捕获到一个视频链接请求，经确认返回的视频携带了水印，如图13-2所示。

从这两个数据包可以得到一个结论：保存至相册的视频和App内播放的视频是两个不同的链接。
接下来要对视频地址进行反推，从而找到最初的请求地址。
利用视频链接里面的关键字进行搜索，得知是由另外一个https://xxxxx.xxxxx.com/xxxxx/v1/play/?video_id=xxxx请求而来（后续称为“播放请求”）。
该请求返回“302”状态码通知客户端进行重定向，HTTP头部的“Location”字段就是重定向的地址，也就是最终的无水印视频地址，如图13-3所示。

那么这个播放请求地址又从何而来呢？
继续搜索关键字，最终定位到https://xxxxx-xxxxx.xxxxx.com/xxxxx/v1/feed/?iid=xxxx请求，该请求返回的JSON数据中有一个“play_addr”字段，里面的“url_list”就是播放请求地址列表了。
同理，携带水印的地址位于“download_addr”字段，如图13-4所示。

抓包分析就到此结束了，接下来要做的是分析“保存至相册”功能的实现及程序对“play_addr”字段的处理流程。
```

### 13.2.2 用 FLEXible 获取 Controller

```
若要分析“保存至相册”功能的实现，必须要先找到它的Controller才行，这几乎成为iOS逆向工程的一个定式。
本节使用FLEXible来获取Controller。
注入FLEXible后，单击“select”按钮选中“保存至相册”控件，并单击“views”按钮，根据UI层次结构很轻松地确定Controller为AWEAwemeShareViewController，如图13-5所示。
```

### 13.2.3 用 Frida 定位按钮响应方法

```
找到AWEAwemeShareViewController之后，使用frida-trace跟踪该类的所有方法，并单击“保存至相册”按钮，输出日志如下：
frida-trace -U -f com.ss.iphone.ugc.Aweme -m "-[AWEAwemeShare View Controller *]"
```

```
从日志函数可以看出，“-[AWEAwemeShareViewController clicked:]”是按钮单击后的响应方法，那么参数0x6b是什么呢？
笔者猜想应该是类型代码，为了更有说服力，再单击一下“收藏”按钮，输出日志如下：
至此已经确定0x6b就代表“保存至相册”，
“收藏”功能则为0x80，
该功能码最终传递给了“-[AWEAwemeShareViewController_shareAndDismiss:]”方法，因此后面需要重点分析它的实现，类型代码也要密切关注。
```

13.3 水印控制逻辑分析
-------------

```
将目标文件载入IDA进行反编译，转到上一节定位到的“-[AWEAwemeShareViewController_shareAndDismiss:]”方法。
1.第一次追踪分析密切关注最后一个参数（笔者已将其命名为“type”），此处传入的是0x6b，所以第15行开始的判断条件不会成立，
直接调用了最后的“+[AWEShareServiceshareByType:completion:]”方法，如图13-6所示。

继续使用frida-trace跟踪AWEShareService类，观察0x6b的传递次序：
frida-trace -U -f com.ss.iphone.xxx.xxxxxx -m "+[AWEShareService *]" -m "-[AWEShareService *]"

从日志看出0x6b最后传递给了“-[AWEShareService__prepareWithShareModel:aweme:type:completion:]”方法，
用IDA查看其关键代码时发现内部实际又调用了AWEShareService Utils类的方法实现，如图13-7所示。
```

```
2.第二次追踪分析继续使用frida-trace跟踪AWEShareServiceUtils类：
frida-trace跟踪AWEShareServiceUtils类
通过日志发现0x6b最后传递给了“+[AWEShareServiceUtilsdownloadAndShareWithURLString:videoModel:distinationURL:shareType:hasWatermark:shouldAddEndWatermark:saveAsLivePhotoEnabled:shouldSaveDirectly:preprocess:completion:]”方法，用IDA查看关键代码，发现内部实际调用了“downloadVideoWithURLGoup:destinationURL:progress:completion Handler:”方法，如图13-8所示。

根据方法名的含义大概猜测出到这里就开始下载视频了，那么这个传入的URL是否就是带有水印的那个URL呢？用Frida脚本对其进行Hook，将参数打印出来一探究竟。由于第一个参数是NSArray，所以采用遍历输出：
if(Objc.available){
  try{
    Interceptor.attach(Objc.classes.WWRShareServiceutils['+ downloadVideoWIthURLGoup:destinationURL:progress:completion Handler:'].implementation,{
      onEnter:function(args){
        console.log("downloadVideoWithURLGoup:")
        var array = ObjC.Object(args[2])
        var count = array.count().valueOf();
        for(var i=0;i!==count;i++){
          var element = array.objectAtIndex_(i);
          console.log(element)
        }
      };
    }catch(err){
      console.log("[!]Exception: " +err.message);
    }
   }
}
注入脚本后，获得一组URL地址：
frida -U -f com.sss.iphone.xxx.xxxxx -l xxxxx.js --no-pause

通过Charles查看这些地址的来源，发现它们正是“download_addr”字段的内容，使用这个字段而非“play_addr”字段是否就是返回带水印视频的关键呢？
从之前的Frida脚本执行来看，“+[AWEShareServiceUtils_URLListForAwemeModel:forBTDShareType:hasWatermark:shouldSaveDirectly:shouldAddEndWatermark:]”方法最有可能完成相关的功能，用IDA查看其伪代码后发现在285行有明显的控制逻辑，
如果“+[AWEShareServiceUtils shouldForbidWartermarkWithAweme:]”方法返回true，就会使用“playURL”中的地址，否则使用“downloadURL”中的地址，如图13-9所示。
至此，对下载视频添加水印的功能实现就分析完成了。
```

13.4 配置开关分析
-----------

```
本节介绍如何为这个App添加配置开关。
```

### 13.4.1 获取 “通用设置” 页面的 Controller

```
注入FLEXible后，单击“select”按钮，选中“通用设置”页面的任意一个控件，并单击“views”按钮，根据UI层次结构可知AWEGeneralSettingViewController为该页面的Controller，如图13-10所示。
由UI层次结构还可以知道，该页面实际上是一个UITableView，这就涉及数据源和数据模型的问题。
```

### 13.4.2 寻找数据源

```
UITableView需要数据源(DataSource)来显示数据，它会向数据源查询一共有多少行数据以及每一行显示什么数据等。
没有设置数据源的UITableView只是个空壳。
凡是遵守UITableViewDataSource协议的Objective-C对象，都可以是UITableView的数据源。
UITableViewDataSource有两个方法是必须实现的（还有一些是可选的），如下：
@required
//这个方法用来设置tableView每个分组的行数
-(NSInyeger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
//这个方法用来返回cell，即用来控制每一行返回的内容
-(NSTableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;

下面就从这个特征入手，尝试寻找数据源。首先在IDA中过滤AWEGeneralSettingViewController类，并没有找到这些方法，如图13-11所示。

既然子类没有找到，那么一定在它的父类中。使用class-dump导出头文件：
class-dump -H xxxxx -o ./headers

打开AWEGeneralSettingViewController.h文件查看继承关系，可以看到继承自AWE SettingBaseViewController类：

继续转到AWESettingBaseViewController.h文件，该类遵守UITableViewDataSource协议，实现了两个必要方法，具体如下：

寻找数据源的工作就完成了，AWESettingBaseViewController就是最终的数据源。
```

### 13.4.3 寻找数据模型

```
通俗地说，模型就是数据的显示结构。
一个UITableView要“活”起来，就必须有数据模型的支持，否则每个列表的数据都将是固定不变的。
数据模型（DataModel）是一个单独的类，包含标题数据和行数据等内容。
数据源中的“-(UITableViewCell)tableView:(UITableView)tableViewcellForRowAt Index Path:(NSIndexPath*)indexPath;”方法搭建了DataModel和Cells之间的桥梁。

在IDA中转到该方法，一眼就看到一个viewModel方法，从名称来看这就是数据模型，其中的sectionDataArray应该是“设置”页面每个区域的数据，如图13-12所示。

用IDA查看“[AWESettingBaseViewModel sectionDataArray]”方法发现它没有任何实质内容，可见其真正的实现在子类中。

按照前面AWEGeneralSettingViewController的命名方式，不难猜测子类名称很可能是“AWEGeneralSettingViewModel”，在class-dump导出的头文件中搜索一下，果然找到了AWEGeneralSettingViewModel.h文件，内容如下：

至此，“通用设置”页面的数据模型就找到了。
```

### 13.4.4 分析数据模型

```
现在需要分析“-[AWEGeneralSettingViewModel sectionDataArray]”方法，为插入自己的Section及Cell做准备。

1.Section的数据模型

用IDA分析“-[AWEGeneralSettingViewModel sectionDataArray]”方法，
得知内部创建了itemsArray及ignoreItemsArray数组，
分别插入了一些字段（如53、54、55）后又调用了“+[AWESettingSectionFactorymodelWithType:itemsArray:ignoreItemsArray:registerAt ViewModel:”方法，如图13-13所示。接着分析“+[AWESettingSectionFactorymodelWithType:itemsArray:ignoreItemsArray:registerAtViewModel:”方法，可知它是根据Type（此处传入的Type为0）来创建各个Section（AWESettingSectionModel对象）的，然后会调用“+[AWESettingSectionFactory_buildSettingItemModelWithItems:ignoreItemsArray:viewModel:]”创建该Section下的各个子项，

最后调用“-[AWESettingSectionModel setItemArray:]”将子项插入Section后返回即可得到所有Section的数据模型。关键代码如图13-14所示。
```

```
2.Item的数据模型分析“+[AWESettingSectionFactory_buildSettingItemModelWithItems:ignoreItemsArray:viewModel:]”方法的实现细节，发现它主要是遍历itemsArray数组（即第一个参数）的每个元素，
如果该元素不在ignoreItemsArray（即第二个参数）列表中，则调用“+[AWESetting ItemFactory modelWithType:registerAtViewModel:]”方法根据传入的Type值获取一个AWESettingItemModel对象插入到settingItemArray数组中，遍历完成后将settingItemArray数组返回即可得到所有Item的模型。
由于此时itemArray中包含54、55内容，所以会分别创建“切换语言”和“非WiFi下自动播放”的Cell，与“通用设置”页面的显示吻合，如图13-15所示。
```

```
3.流程梳理
  上述过程用frida-trace跟踪一下可以更加直观地显示，具体如下：
  
  经过上述分析，现在可以Hook“+[AWESettingSectionFactory_buildSettingItemModel WithItems:ignoreItemsArray:viewModel:]”方法，
  如果当前ViewModel是AWEGeneralSetting ViewModel，则可以在itemsArray（第一个参数）中插入一个自定义的Item，当然还得在“+[AWESettingItemFactorymodelWithType:registerAtViewModel:]”方法中添加对应的Cell创建代码。
```

13.5 本章小结
---------

```
本章分为两部分。第一部分通过Charles抓包分析，确定存在多个视频源，包括有水印和无水印的视频，然后借助FLEXible分析UI，找到了“保存至相册”按钮的响应方法，接着使用frida-trace完成了对水印控制逻辑的分析。
第二部分主要分析了App的配置开关实现，从获取“通用设置”页面的Controller开始，再到寻找数据源及数据模型，最终得到了相应的实现逻辑。
```

第 14 章 实战 3：某游戏广告及内购流程分析
========================

14.1 目标 App 介绍
--------------

```
本章的实验目标是一款以经典打砖块玩法为主的休闲趣味游戏App。
在游戏中，玩家控制方向、发射小球将砖块全部消灭掉即通过关卡。
游戏画面简约精致，玩法灵活简单，能带给玩家全新的打砖块体验。

目标App存在三个明显的广告位：分别是开局广告、暂停广告及结束广告，分别如图14-1～图14-3所示。

在暂停广告页面还明确告诉你，通过内购方式可以移除广告。本章将从多个角度分析广告弹出的程序运行过程。
```

14.2 分析广告逻辑
-----------

```
由于目标App的广告位置比较显眼，笔者决定从UI入手分析其显示逻辑，从而找到底层最关键的代码。
```

14.2.1 使用 Reveal 定位广告窗口
-----------------------

```
使用Reveal载入程序后，在中间的三维视图中选中广告窗口，发现它是一个封装在GADAdView类里面的UIWebView控件。
然后继续找到GADAdView的上层为GADBannerView类，如图14-4所示。

从GADBannerView的命名上不难猜测它就是广告视图，为了确保万无一失，需要进一步求证。还记得在使用Cycript分析目标时用过的隐藏控件技巧吗？先复习一下：

  cy# [#0x155d9f220 setHidden:YES]
这里同样使用这个技巧，不过使用Reveal进行类似的操作就简便多了：
左边选中GADBannerView类，右边切换到“Layer”选项卡，然后勾选“Hidden”复选框，如图14-5所示。
此时页面顶部的广告消失，说明目标找对了。接下来对GADBannerView类进行深入分析。
```

### 14.2.2 定位 GADBannerView 类的初始化方法

```
为了便于分析，先脱壳后使用class-dump导出目标App的头文件：
class-dump -H xxxx -o ./headers

当前目标App版本为1.2.9(102009)，虽然只有22.5MB，但其结构却非常复杂，class-dump共导出了2786个头文件。
查看class-dump导出的GADBannerView.h文件可以明显看到的与初始化有关的方法就多达6个：

由于没有进行动态调试，所以不能确定到底调用哪个进行了初始化，只好将它们全部Hook筛选一遍。
可以先利用logify.pl生成所有基础代码，再进行少量修改使其编译通过
 logify.pl ./headers/GADBannerView.h
 安装插件后，从打印的日志来看，最初调用了“-(id)initWithAdSize:(structGADAdSize) arg1”方法来进行初始化，如图14-6所示。
 
既然基本确定了调用方法，那就尝试让它返回失败，看一下是否会使广告消失，从而对以上分析加以验证将代码改为：
 
遗憾的是，程序还没进入主界面就崩溃了，可见代码中并没有判断GADBannerView是否初始化成功就直接调用了后面的方法，导致了崩溃的发生。

下面继续分析GADBannerView类加载广告的方法。
```

### 14.2.3 定位 GADBannerView 类加载广告的方法

```
查阅资料可知GADBannerView是谷歌广告SDK的一部分，在https://developers.google.com/ad-manager/mobile-ads-sdk/ios/api/reference/Classes/GADBannerView可以查看官方示例：

从其中的注释来看，“loadRequest:”极有可能是加载广告请求的。对它进行Hook测试：

再次打开程序验证上述猜想，开局广告消失了，不过暂停后的广告还是存在，对此需要继续深入分析。
```

### 14.2.4 定位 GADBannerView 对象的创建方法

```
经过上一节的测试，即使广告不再加载了，GADBannerView也会在后台创建，如图14-7所示。

既然有多处广告，那么按照良好的编程风格来说，通常会在一个整体的方法或函数里面进行初始化，这个时候就要用到IDA了。

将目标文件拖到IDA中等待分析完毕，对“-[GADBannerView initWithAdSize:]”方法查找交叉引用，发现仅“-[AppController initBannerAndInterstitial]”引用了它，如图14-8所示。

通过分析“-[AppController initBannerAndInterstitial]”方法可知，其中创建了多个广告窗口，主要代码片段如图14-9所示。

先将其Hook掉：

再次测试，开局广告没有了，经Reveal确认，GADBannerView也不再创建，如图14-10所示。

不过这时暂停广告还会出现，是不是AppController里面还有其他的方法被忽略了呢？

打开AppController.h文件查看，在“- (void) initBannerAndInterstitial”之上果然找到了另外一个可疑的方法“-(void)initNaitveAd”。

此时无须再用IDA分析了，直接Hook后查看即可：

这时再测试，发现游戏的暂停广告和结束广告都消失了，页面上也不会创建广告窗口，如图14-11和图14-12所示。
```

14.3 分析内购流程
-----------

```
游戏里面一般都需要通过内购方式购买道具、金币及钻石等，而且目标App的广告与内购流程相关，本节将从广告入手来分析内购流程。
```

### 14.3.1 定位关键类

```
在游戏暂停时，底部有个“移除广告”的按钮，单击后会触发内购逻辑，由于目标应用已经脱壳，所以会提示“购买失败”，这是App的完整性校验所致，如图14-13所示。
```

```
现在就以这个提示文字为突破口来分析内购流程。
在IDA字符串窗口搜索“购买失败”关键字（默认情况下是不支持中文搜索的，需要在字符串窗口快捷菜单中选择“Setup”命令，然后按照图14-14所示进行设置）。

查找字符串交叉引用发现“-[CMPPurchaseManagerpaymentQueue:updatedTransac tions:]”方法调用了它，如图14-15所示。

因此应该将重点放在CMPPurchaseManager类里面，下一小节分析它的流程。
```

### 14.3.2 追踪 CMPPurchaseManager 类

```
查看CMPPurchaseManager.h文件发现有20多个方法，需要精准判断“移除广告”按钮调用了哪个方法，若是逐个猜测显然有些费力，所以借助ANYMethodLog来追踪其调用过程，代码如下：

现在要追踪正常情况下的调用流程，所以从App Store安装一份没有脱壳的版本，单击“移除广告”按钮，在输入密码那一步单击“取消”按钮，得到图14-16的日志信息。

分析日志可知，发起购买操作从“-[CMPPurchaseManagerbuyProductWithUserID:platformType:productID:]”方法开始。
本节不对购买细节（这是系统决定的）进行分析，而是要找到购买后的代理方法（回调方法）。

由日志可知，程序最后调用了“-[CMPPurchaseManagerverificationResponseWithResultStatue:orderID:productID:count:timeStamp:msg:]”方法来处理返回结果，那么它肯定会回调到上层，只要顺藤摸瓜就一定能找到最终的处理逻辑。
对其进行分析，发现最后将返回结果抛给了“purchasedWithResult:”方法，如图14-17所示。

现在只知道该方法来自CMPPurchaseManager类的delegate，也就是说“purchasedWithResult:”是一个代理方法，那么delegate是什么类型呢？
很遗憾，IDA没有给出友好提示，所以需要找到谁实现了这个方法才能确定具体的类型。笔者使用IDA搜索，很幸运只找到一个结果，那就是CMPPurchase类，也就是说CMPPurchaseManager的delegate为CMPPurchase，如图14-18所示。

定位到“-[CMPPurchase purchasedWithResult:]”方法，其逻辑也相当简单，在最后调用的“+[Purchase didReceivePurchaseWithResult:]”就是上层的回调了，如图14-19所示。
```

### 14.3.3 追踪 Purchase 类

```
现在暂时不去分析回调的实现，试想一下，既然回调在Purchase类中，那购买请求也应该是由它发起的，不然逻辑就显得有点怪。
那么Purchase类与CMPPurchaseManager类又是怎么关联起来的呢？带着这个疑问，使用ANYMethodLog进行追踪来看一下调用过程：

调用日志如图14-20所示。

很明显，Purchase调用了“+[Purchase charge:]”方法后就触发了回调，那这个“+[Purchase charge:]”一定就是发起请求的方法了，
查看其伪代码后就会发现，
它先是调用了“+[CMPPurchaseHelperbuyProductWithUserID:platformType:productID:]”，
最后调用的是“-[CMPPurchaseManager buyProductWithUserID:platformType:productID:]”，
再结合之前的分析，整个逻辑就基本理顺了，如图14-21所示。

另外可以看到，输入参数productId经过了一次转换得到一个字符串类型的str_productId后，才传入下一层。
从“objectAtIndex:”方法推测qword_10143E9D0应该是一个数组类型，查看其交叉引用，最后在InitFun_75内找到了它，果然不出所料，它是一个NSArray类型，里面存放了各种与productId对应的产品类型字符串，如图14-22所示。

这些字符串稍后都要用到，这里大家先有个印象。
```

### 14.3.4 分析回调处理逻辑

```
内购流程结束后，会触发“+[Purchase didReceivePurchaseWithResult:]”方法处理最终的购买结果。

先来看看它的输入参数是什么，
Hook代码如下：

捕获的日志如下：

显然这里传入的是一个JSON字符串，“productId”就对应了上一节分析的InitFun_75函数里面的字符串，表示当前购买的商品。
进一步分析该函数可知，当“status==101”为真时会提示成功。关键代码如图14-23所示。

那么这些JSON数据又是怎么构成的呢？这就涉及内购结果的构造过程，下一小节继续分析。
```

### 14.3.5 分析内购结果构造过程

```
现在将目光转向到“-[CMPPurchaseManagerverificationResponseWithResultStatue:orderID:productID:count:timeStamp:msg:]”方法内部，

因为这是“+[PurchasedidReceivePurchase WithResult:]”方法的调用点。
根据关键代码可知，内购结果中存在5个必要元素，分别为orderId、status、count、timeStamp及productId，如图14-24所示。

至此，对内购流程的分析就完成了。
```

14.4 本章小结
---------

```
本章分为两部分：
第一部分通过Reveal对UI的分析定位到广告窗口所属的GADBannerView类，
然后利用class-dump导出头文件，
对一些可能的方法逐个进行Hook测试，找到了该类的初始化方法，接着分析了它加载广告的方法，最后定位了该类对象的创建方法；
第二部分通过对内购流程的分析，追踪了回调函数内的处理逻辑，分析了内购结果的构造过程。
```

第 15 章 实战 4：某物联网设备登录协议及安全隐患分析
=============================

15.1 目标 App 介绍
--------------

```
说起物联网，大家熟悉的有GPS、智能电表、智能手表及网络监控等。
本章分析的就是一款风格简洁时尚、用户体验友好且功能强大的网络监控设备客户端，该客户端支持在手机上添加摄像头硬件设备，支持多设备同时管理和监控，支持实时语音对讲和查看实时视频。
笔者出于学习的目的，对其协议进行了全方位的分析。在分析的过程中偶然发现了一些安全隐患，本章将对其进行讨论。
```

15.2 登录协议分析
-----------

```
对App的协议分析通常从登录开始，按照设计逻辑来说，后续的所有操作都会基于登录后的令牌（token）进行鉴权。登录协议算是App中最为复杂的一环（当然是相对而言的），可能涉及各种算法及签名规则，这就需要抽丝剥茧逐个击破。
本节将会按照笔者在日常工作中所采用的流程进行分析。
```

### 15.2.1 确定可变字段

```
协议分析的第一步通常是进行数据包采样，目的是区分哪些字段是随主体内容不同而发生变化的，哪些字段是固定的。
配置好Charles后，打开目标App并输入手机号和错误登录密码（笔者输入了“123456”，输入错误密码是为了不让登录成功的数据干扰抓包结果），单击“确定”按钮后，捕获到的数据包如图15-1所示。
关闭App，再次重复以上步骤（注意密码要和上一次输入的一样），捕获到的数据包如图15-2所示。

将两次抓包的数据进行对比，很容易得到表15-1所示的数据。

结论显而易见，只有request_id和verify字段的内容是可变的，而且它们是加密过的，
也就是说分析这两个字段数据的来源及算法就能理清登录流程。
```

### 15.2.2 定位关键点

```
将主文件拖到IDA中进行反编译，然后根据登录请求的关键字“user/user”直接搜索字符串，非常幸运仅找到一处，如图15-3所示。

双击找到的条目，按〈X〉键查找交叉引用，共找到32处。
接着依照关键字“login”开始排除，最终锁定了一个“-[JABottomRequestAPIja_loginWithRequestID:Verify:User:Password:AppBundle:CodeProtect:UniqueID:Token:AppBundleID:DeviceName:Success:Failure:]:”方法
（该方法名太长，后续简称它为“登录方法”），如图15-4所示。

关键点已经定位到了，下一步就是对它展开分析，找出每个参数的算法。
```

### 15.2.3 分析参数来源

```
用IDA查看登录方法的伪代码可知，
这里是组包及最后的发包过程：将明文密码进行MD5处理后和其他参数一起构成一个字典，
最后调用“-[JARequestja_post:Parameters:Progress:Success:Failure:]”方法发包，关键代码如图15-5所示。

由于登录方法的输入参数就是所需的字段，所以往上回溯一层应该就能找到关键了。
还是使用〈X〉键对登录方法查找交叉引用，在sub_10019A260中找到了唯一调用，如图15-6所示。

用IDA转到sub_10019A260函数中，将一些变量重命名后，流程变得更加清晰，如图15-7所示。

verify字段由“-[JAEncrypter encryptVerifyWithUser:Nonce:RequestID:]”方法生成，从命名来看这里涉及了加密算法，这一点之后再分析。

目前要做的是找出该方法需要的3个参数：user、nonce及request_id。

笔者采用LLDB添加断点的方式来探寻，首先在IDA中找到“-[JAEncrypterencryptVerifyWithUser:Nonce:RequestID:]”方法调用点的偏移地址为0x000000010019A358，如图15-8所示。

用LLDB对其添加断点，然后保持Charles处于开启抓包状态，
输入账号和密码成功中断后，将一些关键参数打印出来，具体如下：
  con
  bp 0x000000010019A358
  c
  po $x0
  x/s $x1
  po $x2
  po $x3
  po $x4
  
从打印结果可知X2寄存器（user参数）表示登录手机号，那么另外两个参数值是怎么来的呢？
别忘了现在还在用Charles抓包，用“9439b94c38c5e35734ffad9b23a68b51”作为关键字进行搜索，果然找到了一条记录，如图15-9所示。

原来nonce和request_id参数是从https://xxxxx.xxxxx.com/message/nonce?method=get请求回来的。
尝试使用Charles重发一下该请求，返回正常，说明没有其他校验。

所有参数来源都清楚了，接下来的重点是分析verify算法。
```

### 15.2.4 分析 verify 算法

```
分析“-[JAEncrypter encryptVerifyWithUser:Nonce:RequestID:]”方法可知，
将输入的3个参数转换成NSArrary类型的数组后，传入了“-[JAEncrypter_encryptVerify:]”方法继续进行加密处理，如图15-10所示。

这里需要注意的是数组的顺序，
静态分析后得知顺序为nonce→user→requestId。
也可以用LLDB求证一下。

在第46行按〈tab〉键切换回反汇编模式，得到偏移地址为0x00000001004A93D8，然后使用LLDB操作如下：
 bp 0x00000001004A93D8
 c
 po $x2
 
 接着进入“-[JAEncrypter _encryptVerify:]”方法进行分析，这里才是关键，整个处理可以分为两部分，如图15-11所示。
 
 ● ①部分：对传入的NSArray进行遍历，依次取出每个元素转换成大写之后拼接起来，结合上一步的分析，可以描述为str=uppercase(nonce+user+request_id)。
 
 ● ②部分：在str后面追加了一个字符串，该字符串来源于“-[JAServerskESEncrypter DisturbStr]”，暂时称它为salt，下一节再分析它的值。做完以上两步之后，调用“+[JASecurityUtil MD5:]”方法计算hash值，结果就是verify字段的值了，整理一下可以描述为：
 verify = md5(uppercase(nonce+user+request_id)+salt)
```

### 15.2.5 分析 salt 值

```
仍然采用静态分析来寻找salt值。
找到“-[JAServers kESEncrypterDisturbStr]”方法，
结果看到它只是取了一个_kESEncrypterDisturbStr属性，
也就是说这个是get方法，如图15-12所示。

现在笔者只对set方法感兴趣，关心set方法在什么时候调用。
尝试在IDA中搜索“-[JAServers setKESEncrypterDisturbStr:]”方法，不出所料顺利找到了。
对其查找交叉引用，最终在“-[AppDelegate initJAServers]:”方法中找到，如图15-13所示。

继续分析“-[AppDelegate initJAServers]:”方法可知，
kESEncrypterDisturbStr来源于verifyMixStr方法，如图15-14所示。

笔者已经对一些变量进行了重命名，所以找到appInfo就能知道verifyMixStr方法属于哪个类。
联系上下文很容易发现appInfo从“-[JAODM appInfo]”方法而来，
按〈F5〉键查看一下伪代码可知其返回类型为JAODMAppInfo，具体如下：

所以verifyMixStr方法属于JAODMAppInfo类。
查看“-[JAODMAppInfoverifyMixStr]”可知，这也是一个get方法，
必然会存在对应的“-[JAODMAppInfosetVerifyMixStr:]”方法，
对其查找交叉引用，最终定位到“-[JAODMAppInfoinit]”方法内，
从关键代码可知verifyMixStr字段是从安装目录下的JAODMConfigInfo.json文件中读取的，如图15-15所示。

找到安装目录下的JAODMConfigInfo.json文件，用Sublime Text打开，可以看到verifyMixStr字段的值为“Japass^2>.j”。

至此，verify的整个算法就完成了，整理一下就是：

verify = md5(uppercase(nonce+user+request_id)+Japass^2>.j)
```

15.3 安全隐患分析
-----------

```
不管是广度上还是深度上，物联网都已经超越了互联网，互联网也成了物联网的一个组成部分。
但不管物联网还是互联网，用户的信息安全还是首要的，在面临为用户提供便利还是安全这道选择题时，厂商几乎无一例外地会选择便利，这样就会造成一些本来可以避免的安全隐患。
```

### 15.3.1 安全隐患成因

```
打开Charles抓包，在目标App的右上角单击“+”号添加设备，设备类型选择“录像机”，随意输入一个ID后单击“存储”按钮，如图15-16所示。

由于ID是随意输入的，必定会提示“云ID不存在”，此时Charles捕获的数据包如图15-17所示。

返回的JSON数据如下：

问题来了，刚刚笔者添加设备的时候没有输入密码竟然也可以提交，难道客户端没有进行空字符串过滤？

恰好笔者有个朋友从事监控工程方面的工作，询问得知很多设备出厂前的默认用户名都是“admin”，密码都为空，极少有人去改动它。

笔者获得一个真实云ID进行抓包测试，返回的JSON结果如图15-18所示。

看到这里，笔者很震惊，这是个极严重的安全隐患，只要持有正确的云ID，无需任何授权就能随意添加设备，之后的监控画面都会暴露出来，毫无隐私可言。
```

### 15.3.2 安全隐患复现

```
既然知道了网络上的很多设备存在空密码安全隐患，那就可以写一小段Python脚本不断地遍历尝试添加，以复现该过程。关键代码如下：

这段代码需要先完成登录协议，获取登录后的access_token才能使用。
代码对起始ID和结束ID之间的设备进行遍历，尝试添加设备。
由于已经抓取了正确云ID及错误云ID的返回结果样本，所以利用返回字段来精确判断是否添加成功。

脚本运行一定时间之后，打开目标App刷新设备，从右边的滚动条长度就可以看出利用此安全隐患添加成功的设备非常多，如图15-19所示。

设想一下，将来会有数以万亿个物联网设备，这类安全问题到时会非常重要，需要得到厂商的高度重视。
```

15.4 本章小结
---------

```
本章分为两个部分：第一部分主要分析登录协议，利用抓包采样的方式确定了可变字段，再使用关键字在IDA中直接搜索来定位关键点，接着分析了每个参数的来源、verify算法、salt值；
第二部分主要分析添加设备过程中发现的一些安全隐患，并验证此安全隐患带来的危害性。
读者应对登录控制逻辑中的常见隐患有所认识并加以防范。
```

第 16 章 实战 5：某乐谱 App 下载协议与安全问题分析
===============================

16.1 目标 App 介绍
--------------

```
本章的实验目标是一款可视听的乐谱App，具有海量钢琴乐谱、吉他乐谱、尤克里里乐谱、电子琴乐谱，更有趣味小游戏帮用户练习识谱听音，采用闯关模式，挑战力十足。
目标App的乐谱分为免费和收费版本，本章将对该App中的收费乐谱进行分析。
```

16.2 数据包采样
----------

```
协议分析的第一步是数据包采样，目的是区分出哪些字段是变化的，哪些字段是可以伪造的。
配置好Charles后，打开目标App并选择乐器为“吉他”，并将页面切换为“谱库”，方便进行本节的采样过程。
```

### 16.2.1 确定可变字段

```
随便抽取两个吉他乐谱进行下载采样，发现除了yuepuid、r1、r2、token字段有变化，其他都是固定的，分别如图16-1、图16-2所示。

返回的结果为JSON数据，data字段里面包含了具体的URL，如下：

可变字段已经确定了，现在再来做个实验：将请求网址复制到浏览器中打开，发现返回的JSON和在Charles里面得到的一样，

因此能确定两点：服务端没有对HTTP头进行校验，可以任意伪造；
服务端没有对时间戳进行检测，可以进行重放。

这对App的安全是不利的。
```

### 16.2.2 字段依赖分析

```
4个变化字段中，yuepuid从命名上看很明显是乐谱编号，那么其他3个字段之间会有联系吗？
可以利用Charles的断点功能修改某个参数来确定一下，如图16-3所示。
已知数据包可以进行重放，现在就来利用Charles来重放一次来触发断点，如图16-4所示。

断点触发以后，修改r1的值为“1234567890”，然后重新发包，如图16-5所示。

服务端返回的信息如下：

不出所料，服务端并没有返回乐谱地址，说明r1和token之间存在关联。
继续进行其他字段的修改，得出结论：yuepuid、r1、r2、token字段都存在相互依赖的关系，
需要进行逆向分析。
```

16.3 签名算法分析
-----------

```
确定了yuepuid、r1、r2、token存在相互依赖关系，而token像是对这些数据的签名，
到底是不是呢？本节就来分析一下。
```

### 16.3.1 静态定位关键函数

```
将App脱壳后，拖进IDA进行分析，
在字符串窗口搜索关键字“codeindex.php?d=guitar_ios&c=index&m=get_url”，
因为字符串没有加密，所以一下就找到了。
查看交叉引用可知，该字符串被“+[WebDefineMUSIC_DATA_URL:r1:r2:appVersionStr:]”方法引用，如图16-6所示。

静态分析该方法并将变量重命名，
它先调用“+[WebDefine md5key]”方法获取了一个md5key，然后将r2、yuepuid、md5key、r1拼接起来计算出md5，得到token。
伪代码如图16-7所示。

现在可以确认token就是对这些数据的签名，其算法描述为：
 token = md5(r2+yuepuid+md5key+r1)

现在除了yuepuid已知，其他都需要进一步分析。
先进入“+[WebDefine md5key]”方法看一下，发现它返回一组固定的数据：

此方法使用静态分析看起来有些费力，配合动态调试会更快地得到答案。
```

### 16.3.2 动态调试获取主要参数

```
由于事先没有恢复符号表，所以不能添加符号断点，
先找到“+[WebDefinemd5key]”方法的偏移地址为0x0000000100730AC8：

用LLDB对其添加断点，返回后打印x0的值就得到md5key了，操作如下：

debugserver *:8888 -a ChinaPYG
con
bp 0x00000000100730AC8
c
finish
po $x0

md5key的值为“jtyuepu_yt.sc_md_-jiami...qlkj”，
写一段Python代码并取第一次采样得到的数据来验证一下结果，关键代码如下：

import hashlib

def getToken():
  yuepuid = "53717"
  r1 = "-408055501"
  r2 = "1744031836"
  md5key = "jtyuepu_yt.sc_md_-jiami...qlkj"
  token = md5(r2 + yuepuid + md5key + r1)
  return token
  
if __name__ == '__main__':
  print("token=" + getToken())

token = 133213345678233456789
```

### 16.3.3 栈回溯找出其他参数

```
现在剩下r1、r2数据未知，怎么找呢？读者应该发现了，r1、r2、yuepuid都是作为参数传进来的，因此对“+[WebDefine MUSIC_DATA_URL:r1:r2:appVersionStr:]”方法添加断点，并向上回溯一层就能知道r1、r2的来源。
先找到“+[WebDefineMUSIC_DATA_URL:r1:r2:app VersionStr:]”方法的偏移地址为0x0000000100732D7C：

添加断点并打印堆栈信息，确定0x00000001005af008的上一条指令调用了“+[WebDefine MUSIC_DATA_URL:r1:r2:appVersionStr:]”，
换算成IDA中的偏移地址为0x100557008：

bp 0x0000000100732D7C
bt 3
foff 0x00000001005af008

IDA转到0x100557008，根据ARM64传参规则，
x3、x4就是r1、r2的值了，
由x3=x21、x4=x22最终确定r1、r2是调用arc4random函数生成的随机数，
如图16-8所示。
```

### 16.3.4 协议下载乐谱

```
本小节尝试编写代码来实现脱机下载，采用Python的requests模块来完成协议下载乐谱。首先用如下命令安装requests模块：

首先用如下命令安装requests模块：
  sudo pip install requests

然后编写测试代码。其主要部分如下：

下载完成的.gtp文件无法使用Guitar Pro（一款吉他谱查看软件）正常打开，说明它被加密过，本章最后再加以分析，下一节先研究一下本地VIP权限校验的一些安全问题。
```

16.4 VIP 权限校验的安全问题
------------------

```
很多公司为了开发方便和减轻服务器压力，会将一些敏感逻辑及权限校验放到本地，比如早期的某些视频播放客户端，直接开启本地VIP就能看所有的收费电影。
本节所讲的就是基于本地权限校验的安全问题。
```

### 16.4.1 安全问题成因

```
1.协议安全问题在进行抓包的过程中，笔者出于职业习惯，有意单击了一些VIP乐谱，发现服务端仍然返回了乐谱下载地址，但是主页面却提示需要VIP权限才能下载。

既然服务端已经返回了地址，那么肯定是客户端在本地进行了VIP权限判断，从而决定是否需要展示乐谱信息，如果找到本地判断函数，修改其返回值就能展示乐谱了，这是安全问题之一。

2.日志安全问题在分析过程中发现目标App还有个安全问题：过度启用了调试日志。
打开macOS控制台，设置好过滤条件，单击下载VIP乐谱，会出现图16-9所示的日志信息，其中包含“乐谱不免费”这几个字。

在IDA中搜索“乐谱不免费”，发现有多处引用，如图16-10所示。

通常遇到多处调用的时候，比较笨拙的办法是对每个调用都添加断点，但是这里笔者注意到，单击下载VIP乐谱的时候，日志窗口仅有一条日志，这让笔者萌生了一个念头：对日志函数添加断点然后回溯不就可以快速找到调用处吗？
任意查看一条调用，发现用NSLog打印了日志：

用LLDB对NSLog函数添加断点，然后打印调用栈，通过栈回溯可以确定0x1006dee8c前一条语句打印了日志信息，转换成IDA偏移地址为0x1006c6e8c，操作如下所示：
  breakpoint set --name MSLog
  c
  bt 3
  foff 0x0000000106dee8c

下一小节根据0x1006c6e8c地址分析VIP权限的控制逻辑。
```

### 16.4.2 分析 VIP 权限控制逻辑

```
在IDA中转到0x1006c6e8c处，查看附近的相关代码，会发现两处明显的逻辑分支，如图16-11所示。
虚线框所示的就是验证失败的提示，
实线框所示是验证成功后调用“_doDownloadSongData:isSave:downloadFinish:”方法进行乐谱下载的代码，而验证成功与否的逻辑由两个方法控制，分别是“checkUserVIPPowerByType:”和“isVIP”方法。

重点分析“-[VipController checkUserVIPPowerByType:]”方法，
其逻辑是根据传入的type调用相应的函数来判断是否具有某个类型的VIP权限，返回YES就表示具有VIP权限，关键代码如图16-12所示。
根据此处分析得到的控制逻辑，该App的VIP权限检查很容易被突破，需要进行加强。
下面针对乐谱本身进行分析。
```

16.5 乐谱解密过程分析
-------------

```
使用协议下载的乐谱是被加密的，没有经过App的解密处理。
读者可以猜想一下，乐谱解密的最佳时机一般会在什么时候呢？笔者认为，App会在下载乐谱之后立即进行解密，因此本节由入口方法“_doDownloadSongData:isSave:downloadFinish:”展开，来分析App对乐谱的解密过程。

本例中，确定解密算法这一环节通过静态分析及大胆猜测就能做到。
用IDA查看“_doDownloadSongData:isSave:downloadFinish:”方法的伪代码，如图6-13所示。其主要逻辑是，
调用“-[DownloadSongManager_downloadSongDataByUrl:]”方法下载完乐谱后，
再调用“+[SongArchive encryptSongData:oldPassword:newPassword:]”方法对乐谱数据进行加密，
然后将结果保存起来供后续使用。

下载回来的乐谱不是应该解密吗，怎么还加密一次呢？
现在进入“+[Song ArchiveencryptSongData:oldPassword:newPassword:]”方法一探究竟，如图16-14所示。

笔者已经将一些变量重新命名，逻辑也变得格外清晰，主要分为两部分。
● 第一部分：使用AES256DecryptWithKey将songData进行解密，
 参数oldPassword的值就是密钥，
 解密之后再调用“+[SongArchivedecompressSongData:]”方法进行解压得到原始乐谱数据。
● 第二部分：将解密后的原始乐谱数据使用“+[SongArchivecompressSongData:]”方法压缩后，
  再调用AES256EncryptWithKey加密返回，
  参数newPassword的值就是其密钥。
  因此“+[SongArchive encryptSongData:oldPassword:newPassword:]”实际就是用于将乐谱二次加密后保存。
  
  从参数newPassword的来源（来自于passwordWithDeviceID方法的返回值）来看，每个机器对应的密钥不同，这应该是防止复制而做的保护。
  其实对于解密乐谱来说，完全不用管第二部分的内容，将目光锁定到第一部分即可。
```

```
1.数据解密分析
  从AES256DecryptWithKey方法的命名就知道这是AES-256解密，所以不需要再分析下去，只要进入该方法查看其使用的加密模式及填充方式就好了，如图16-15所示。
  这里使用了系统库自带的CCCrypt函数进行解密，只需关注它的参数即可。
  从Xcode中查阅到几个常量的宏表示，将它们代入后结果如下：
  CCCrypt(kCCDecrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding, &v12, kCCKeySizeAES256, NULL, v8,v4,v5,v4+16,&v11);
  这样就能顺利解读出：加密/解密采用了CBC模式，填充模式为PKCS7。
```

```
2.数据解压分析
  而“+[SongArchive decompressSongData:]”从名称来看只能判断是用来解压歌曲数据，并不能猜测出使用了何种解压缩算法，还得进入查看一下，如图16-16所示。
  可以看到，方法内部调用了“+[ZKDataArchive archiveWithArchiveData:]”进行初始化，通过查阅资料，这是ZipKit开源框架的代码（网址为https://github.com/kolpanic/ZipKit.git），也就是说这是zip解压缩算法，无须再逆向其实现细节。
  到此为止，已经完全确定乐谱的加密算法为AES-256，且使用了ZipKit开源库进行压缩处理，其中涉及一个参数oldPassword。
```

```
3. 密钥保护分析
  oldPassword的值由“+[DbSong password]”方法而来，查看其伪代码，发现它和分析签名算法时见过的“+[WebDefine md5key]”方法一样做了处理，让密钥不能显示出来，具体如下：
  这种情况除了使用动态调试方法外，还可以使用一些IDA的静态分析小技巧，
  具体是：在“__int64 v3;”这一行单击右键，选择“Set Ivar type”命令，在弹出的对话框中修改类型为“char v3[14]”，如图16-17所示。
  上述修改的意思是将v3改为一个能容纳14个字符的char类型数组，目的是提醒IDA将其识别为字符串。有些读者可能要问为什么大小是14，而不是13或15呢？
  这其实很简单，v3的类型是int64，占用8字节，而v4～v9的类型都是char，各自占用1字节，共6字节，8字节+6字节=14字节，因此改为14。
  单击“OK”按钮之后，会显示一个询问对话框，直接单击“YES”按钮即可。
  之后密钥就很优雅地显示出来了，这里可以看到是“mUSE1StHebEst”，如图16-18所示。
  是不是很简单呢？有时候多掌握一些IDA的静态分析技巧会让逆向过程更加快捷。
```

16.6 本章小结
---------

```
本章从Charles抓包入手对数据包进行多次采样及测试，最终确定了一些可变字段及固定字段；
在IDA中搜索关键字的交叉引用定位关键函数，通过回溯找出其他必要参数，最终完成了签名算法的逆向分析，基于Python编写了一个协议下载的例子；
接着分析了调试日志暴露的一些安全问题；
最后一部分分析了App对乐谱的解密算法、解压缩算法及AES密钥保护。

在本章中，除抓包分析以外，笔者只使用了IDA静态分析与LLDB动态调试相结合的经典分析方式，没有使用Frida等进行跟踪。
```

第 17 章 实战 6：某经典 GPS 插件授权机制分析
============================

17.1 目标 App 介绍
--------------

```
本章的实验目标是一款iOS定位修改伪装插件，是一款系统级App，通过Cydia或者Sileo添加相应的源直接安装。
它的使用非常简单，只需要在地图上用手指长按选择想要到达的位置（长按后会看到一个标记落在此处，并弹出一个包含该位置地理信息的气泡），然后单击屏幕底部的“开始”按钮就可以进入导航了，如图17-1所示。
目标App只提供了一天的试用时间，之后会由“试用中”变成“未授权”，单击“我的权限”可以进行购买，如图17-2所示。
笔者本着学习的态度来分析它的授权机制。
```

17.2 抓包分析
---------

```
这种带时间限制的授权机制通常需要服务端来控制（也称为“网络验证”），因此使用Charles抓包进行初步分析是最佳选择。
```

### 17.2.1 数据包采样

```
1.第一次采样配置好Charles后，启动程序捕获到域名为“aboutsex.xxxxxxx.com”的数据包，其中有一个地址为https://aboutsex.xxxxxxx.com/xxxxxxx/get_privilege.php的请求引起了笔者的注意（后续称为“get_privilege请求”），它的返回值是一段JSON数据，里面的一些标记通俗易懂，其中的timeMsg和timeMsgs都是加密数据，所以暂时忽略它们的含义，如图17-3所示。

在笔者无意间将机器重启后发现还有一个https://aboutsex.xxxxxxx.com/xxxxxxx/validate.php?device=a61e363938b5b29e3eeb510907d0f92e5d7f34e9的请求（后续称为“validate请求”），它的返回数据和get_privilege请求的返回数据几乎一致，如图17-4所示。

不同的是，validate请求来自SpringBoard，也就是说它是由非主程序发起的，如图17-5所示。

这是因为插件的dylib文件同时注入到了SpringBoard，读者可以将deb包解压出来查看plist文件的配置信息来进行验证。
```

```
2.第二次采样待试用期过后，重新抓包进行第二次采样，抓到的get_privilege请求返回数据如下：

经过多次“killall SpringBoard”尝试，validate请求不再出现，所以推断validate请求与get_privilege请求密切关联。

当get_privilege请求失效（试用期已过）时，validate请求不会再触发，因此validate请求称为“二次校验”。

二次校验能给应用授权机制增加一道安全保障。
为了后面操作方便，将第一次采样得到的试用期内数据分别保存为“get_privilege_response.json”和“validate_response.json”文件。
```

### 17.2.2 判断关键字段

```
服务端返回了多个字段，为了更精准地判断哪些属于关键字段，本次利用Charles的“Map Local”功能将请求返回的数据包用上一节保存的JSON文件替换。
具体规则设置如图17-6所示。

重新启动程序发现由“未授权”变成了“试用中”，证明返回值的替换是成功的，测试一下功能也正常，从中可以看出目标程序在验证数据合法性时不严谨，没有进行时间戳校验，导致只要有一个合法的数据即可无限试用，这是授权机制的一个严重漏洞，大家在软件开发中应当设法避免。

现在修改get_privilege_response.json文件的字段内容，例如将timeMsg和timeMsgs删除，将endTime时间改大：

再次启动程序，过期时间不但没有延迟，反而又变成了“未授权”版本。

如此反复修改测试，发现只要timeMsgs不存在或内容被修改就会出现“未授权”，其他数据无论怎么修改都不会改变授权项，属于障眼法。

接着修改validate_response.json文件的字段内容（注意修改后需要“killall SpringBoard”），
将timeMsgs字段删除后使用正常，所以在这个数据包中timeMsgs字段并没有起作用，而把opened字段删除后使用就不正常了。
经过多次修改测试，最终确定只需要opened为true，就能通过验证。
至此，所有数据包需要的关键数据都弄清楚了，那么这个加密后的timeMsgs字段到底是怎样的？下节见分晓。
```

### 17.3 定位关键函数

```
通过对“timeMsgs”字符串查找交叉引用，非常幸运仅找到一个sub_1000255E0函数调用了它。
函数内部调用了“+[lfILBWSCRdrjVtjc KtWBojMJVmRhgVaJ]”方法返回一个对象，
接着调用了该对象的“jcyuthVjCsrpVMJC:TfeuRyRtGnrZxwxl:”方法，该方法的第一个参数为timeMsgs的内容，第二个参数为0，如图17-7所示。

很显然这些类名及方法名是被混淆过的，不过并不影响分析。
先查看一下“+[lfILBWSC RdrjVtjc KtWBojMJVmRhgVaJ]”方法的实现，
从“_dispatch_once”函数调用及block函数（sub_100079014）的逻辑来看，这是创建了一个lfILBWSCRdrjVtjc对象，如图17-8所示。

熟悉Objective-C设计模式的读者应该知道，这是典型的单例模式做法，“KtWBojMJVmRhgVaJ”的实际名称应该是“sharedInstance”，其代码逻辑如下：

此时只剩下“-[lfILBWSCRdrjVtjc jcyuthVjCsrpVMJC:TfeuRyRtGnrZxwxl:]”方法没有分析，为了快速求证所找的函数是否正确，可以编写一段Frida脚本对该方法进行追踪：

  if(ObjC.available){
    try{
      Interceptor.attach(Objc.classes.lfILBWSCRdrjVtjc['- jcyuthVjCCsrpVMJC:TfeuRyRtGnZxwxl:'].implementstion,{
        onEnter:function(args){
          console.log(ObjC.Object(args[0]),Objc.Object(args[2]), args[3])
        },
        onLevel:function(retval){
          console.log("return=",ObjC.Object(und retval));
        }
      });
    }catch(err){
      console.log("[!] Exception: " + err.message);
    }
  }

加载脚本后，从输出日志可以看到经过该方法的处理后所有数据均已解密，具体如下：
   frida -U -f cn.xxxxxx.xxxxxx -l xxxx.js --no-pause
   
用IDA简单看一下，发现有base64DecodedData方法的调用，还有一些“rsa_st*_rsa”之类的提示。

因为输入参数timeMsgs的内容形如base64字符串，所以这里使用base64DecodedData先解码，从流程上来看是说得通的，下面的“rsa_st *_rsa”很明显说明使用的是RSA算法。
另外有两个C函数非常可疑，它们由W20寄存器控制，而X20寄存器又来自X3（即第二个参数），此处X3的值为0，所以“CBZ W20, loc_10007940C”跳转成立，最终调用了loc_10007940C处的sub_1000C6648函数。如图17-9所示。

对sub_1000C6648函数的分析属于算法范畴，在下一节详细讲解。
```

17.4 授权机制分析
-----------

```
要想彻底了解一个程序的授权机制，就必须分析出它的算法。
在找到关键函数之后，就可以对其授权机制进行分析了。
```

### 17.4.1 去除反调试

```
尝试使用debugserver附加目标进程，瞬间报错“Segmentation fault: 11”后退出，说明目标存在反调试：
  debugserver *:8888 -a xxxxxx

为了去除反调试，先用ps命令找出目标App的完整路径，再使用debugserver直接启动进程，如下：
 ps -ax | grep xxxxxx
 debugserver -x backboard *:8888 /Applications/xxxxxx.app/xxxx

在macOS端与debugserver连接后，使用
 “breakpoint set-name ptrace”对ptrace函数添加断点，并输入“c”继续运行：
 
breakpoint set --name ptrace
c

过一会儿调试器中断，说明ptrace函数被触发，使用bt命令查看调用栈，并利用在第7章动态调试中的LLDB脚本命令foff，查找出IDA中对应的文件偏移为0x100007e40和0x100007e6c，具体如下：
  bt
  foff 0x0000000100013e40
  foff 0x0000000100013e6c
  
为了求证是不是绕过ptrace函数就能进行调试，接着使用“thread return”命令直接退出函数调用，发现程序正常运行，说明分析正确。

在IDA中按〈G〉快捷键，输入调用栈中看到的第一层地址来到0x100007e40处，可以看到sub_100007E00为反调试函数，将其重命名为“AntiDebug”，结合上下文查看其逻辑发现，它通过dlopen、dlsym及dlclose的“黄金搭档”方式在0x100007E3C处使用“BLR X8”调用了ptrace函数。

通过AntiDebug函数的交叉引用（也可以看第二层栈地址0x100007e6c）可知，它在start函数的0x100007E68处被调用，如图17-10所示。

读者可以编写一个tweak将ptrace函数Hook掉（详见10.1.2节），这样就不用每次都使用LLDB进行处理了。
```

### 17.4.2 确定算法

```
先进入sub_1000C6648函数查看其代码，发现已经无法静态分析，如图17-11所示。
现在的任务是找出X5的地址（真实函数调用），
通过LLDB对0x00000001000C6650地址添加断点，
触发后打印X5寄存器的值再计算文件偏移，
最终得到真实函数调用地址为0x1000c01cc。具体如下：
  bp 0x00000001000C6650
  c
  po/x $x5
  foff 0x000000010010c1cc
  
在IDA中转到0x1000c01cc地址，使用〈F5〉键查看其伪代码，发现代码很长，似乎无从下手，而细看代码发现这里出现了“rsa_eay.c”的日志字符串，而且有个“669”的行号，这让笔者感到非常惊喜，如图17-12所示。

通过搜索引擎可以确定rsa_eay.c文件源于OpenSSL的/crypto/rsa目录，但遗憾的是在目标文件中并没有查找到OpenSSL的版本号，因此不能精确定位。

接着换种思路，下载任意版本的OpenSSL，在rsa_eay.c文件的669行附近大致寻找一下有关信息。这类文件一般改动很小，最终找到了以下符合要求的函数：

根据注释知道这里是签名校验（从其函数名也能更进一步知道此处使用了公钥解密）。
将sub_1000c01cc函数重命名为“RSA_eay_public_decrypt”，然后对照源码将一些其他函数也重命名（不是必须的）。
最后一个参数padding决定了填充方式，接下来要找出它的值。
对RSA_eay_public_decrypt函数添加断点，并将X4寄存器打印出来：

  bp 0x0000001000c01cc
  c
  p/x $x4
  
 从这里可以知道padding=1（RSA_PKCS1_PADDING），在rsa.h中找到所有的padding宏定义：
```

### 17.4.3 分析 RSA 公钥读取逻辑

```
既然是RSA公钥解密，那么就涉及公钥的读取。
RSA_eay_public_decrypt函数的第四个参数是“RSA *rsa”，也就是说这个对象里面肯定保存了公钥信息。
重新审查“-[lfILBWSCRdrjVtjc jcyuthVjCsrpVMJC:TfeuRyRtGnrZxwxl:]”方法的伪代码，追踪v12（第四个参数）的来源，发现最终是从lfILBWSCRdrjVtjc类中取了一个名为“_rsa”的属性，如图17-13所示。

用class-dump导出头文件并查看lfILBWSCRdrjVtjc.h，果然和上述分析一致：
 class-dump -A -a -H xxxxxx -o ./headers
 cat ./headers/lfILBWSCRdrjVtjc.h

所幸lfILBWSCRdrjVtjc类的方法不多，逐个查看它们的反汇编代码，发现MqPycOiaMgnpJNBi方法读取了主程序目录下的pub_key.pem文件（从命名上就能看出它是公钥文件），
然后经过sub_1000DDAE4函数将结果赋值给_rsa属性，从日志上还能看出被混淆的lfILBWSCRdrjVtjc类原名应该是CRSA，如图17-14所示。

代码中的sub_1000DDAE4其实是OpenSSL的PEM_read_RSA_PUBKEY函数。

除了利用OpenSSL源代码识别它以外，还有另外一种快速识别方法。
先进入sub_1000DDAE4，看到“PUBLIC KEY”关键字，如图17-15所示。接着在/usr/lib/目录下查看系统自带的OpenSSL动态库，如下：
  ls -al /usr/lib/libcrypto
  
用另外一个IDA载入其中一个动态库（例如笔者选择“libcrypto.0.9.8.dylib”），
搜索字符串“PUBLIC KEY”，利用排除法确定此函数为“PEM_read_RSA_PUBKEY”，

与此同时也知道sub_1000D7970函数实际上是d2i_RSA_PUBKEY，
sub_1000DC964函数实际上是PEM_ASN1_read，函数的所有参数也正确显示了，如图17-16所示。

将sub_1000DDAE4函数及内部函数重命名，然后在函数头按〈Y〉键，将参数修改正确，如图17-17所示。

这种方法免去了下载源代码进行查看的麻烦，对于有导出符号的库非常方便，读者可以参考。
```

### 17.4.4 验证算法

```
需要的数据都有了，现在写一段C代码来测试上述分析的正确性，关键代码如图17-18所示。

笔者为了操作方便，将pub_key.pem内的内容直接嵌入了程序内，
使用PEM_read_bio_RSA_PUBKEY函数从内存读取RSA结构，
与目标程序里面使用PEM_read_RSA_PUBKEY读取pem文件的方法如出一辙。运行后结果如下：

至此，算法分析完成，下面来分析主程序验证流程和二次验证流程。
```

### 17.4.5 主程序验证流程

```
在调用“-[lfILBWSCRdrjVtjc jcyuthVjCsrpVMJC:TfeuRyRtGnrZxwxl:]”方法解密出明文数据后，程序会使用“&”对解密后的数据进行分割，然后取每个键值分别进行处理，如图17-19所示。

图17-19中的字段含义比较清晰，感兴趣的读者可以继续分析以便进一步学习。
```

### 17.4.6 二次验证流程

```
二次验证的数据包由注入SpringBoard的xxxxxxx.dylib发起。
搜索与网络请求有关的类NSURLConnection，仅在“_logos_method$_ungrouped$SpringBoard$processFixedLocation Dict$”函数中找到一处调用。

在“sendSynchronousRequest:returningResponse:error:”同步发送数据之后，将返回结果通过NSJSONSerialization类转换成JSON格式，最后取opened字段的值赋给全局变量“::sCanBeUsed”以决定是否能正常使用，如图17-20所示。

为了求证分析是否正确，编写Frida脚本对“+[NSJSONSerializationJSONObjectWith Data:options:error:]”方法进行Hook：

if(ObjC.available){
  try{
    Interceptor.attach(ObjC.classes.NSJSONSerialization['+JSONObjectWithData:options:error:'].implementation,{
      onEnter:funcation(args){
        console.log(ObjC.Object(args[0],ObjC.Object(args[2]),args[3])
      },
      onLevel:funcation(retval){
        console.log("return=",Objc.Object(retval))
      }
    });
  } catch(err){
    console.log("[!]Exception:"+err.message)
  }
}

frida -U SpringBoard -l xxxxxx.js

至此，二次验证流程分析完毕。
```

17.5 本章小结
---------

```
本章使用的目标App属于典型的网络验证类型，笔者通过Charles抓包采样确认了关键的timeMsgs字段，同时发现了授权机制中的BUG及由SpringBoard发起的二次验证，接着通过IDA交叉引用定位关键函数，然后使用LLDB绕过反调试进入调试过程，确定其使用了RSA算法并通过对应公钥对算法进行了验证，最后分析了主程序的验证流程及二次验证流程。
```